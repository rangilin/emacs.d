<h2 id="toc_0">So much setup</h2>

<p>So, for some crazy reason, I like writing small collection implementations. I don&#39;t worry too much about performance, I&#39;m just writing them as small exercises when I want to write something. Because of their size and fairly straight-forward(haha) requirements, I can use them to experiment with how I write tests. But, often I find setting up a testing framework to feel so heavy-weight.</p>

<p><em>what a pain!</em></p>

<p>I also use simple stacks and queues as introductory challenges when I&#39;m introducing people to the idea of automated unit testing, especially moving to test-driven development. But, there is a bit of a chicken-and-egg situation when first starting: writing tests requires introducing a testing framework, but testing frameworks often assume some base knowledge of testing by hiding a lot of the underlying principles.</p>

<p><em>hard to know where to start!</em></p>

<p>Helping beginners learn to program also has its rewards. When people are still trying to understand the very basics, even things like classes or dependencies can be confusing. Having a test framework potentially diverts us to talking about non-beginner or non-relevant topics.</p>

<p><em>yak-shaving galore!</em></p>

<h2 id="toc_1">When all you have are frameworks, every problem looks like a DSL</h2>

<p>Learning a new testing framework often can involve some form of a DSL. True, it might be as &quot;simple&quot; as learning:
* name your methods in the form testXXX;
* don&#39;t forget the call to assert_XXX.</p>

<p>or it might be more complex:
* method definitions? Oh, we don&#39;t really use those, we have a DSL;
* oh, assertions are actually done by calling methods on the object you are testing.</p>

<p>When you&#39;ve been doing automated unit testing for a while, and you&#39;ve played with different tools, it can be easy to forget that a lot of the testing tool concepts aren&#39;t clear and obvious.</p>

<h2 id="toc_2">Testing Framework? We don&#39;t (always) need no stinkin&#39; testing framework.</h2>

<p>So, what&#39;s to do when we need something quick, or we don&#39;t want to introduce unnecessary complexity? Get back to the basics! To understand that, we can ask ourselves what is at the core of a testing framework? This isn&#39;t actually the right question, though. Let&#39;s get even more basic. What is at the heart of testing? Forget the automated part and think about what you do when you are building without automated tests.</p>

<p>Let&#39;s investigate this with the beginnings of a stack. Put the following into a file and run it.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">  stack = Stack.new
  puts &quot;New stack size is #{stack.size}&quot;
</code></pre></div>
<p>Once we get this passing, we can write another test.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">  stack = Stack.new
  stack.push 1
  puts &quot;Stack size after pushing is #{stack.size}&quot;
</code></pre></div>
<p>Now run this script and see if the messages make sense. We have two tests now.</p>

<p>And so on. The problem here is pretty obvious: this method is fairly inefficient. Every time you run, there is a mental step to interpret the messages. As the number of tests get larger, the feedback cycle to make sure you broke something gets larger and longer.</p>

<p>This is one of the standard arguments for having an automated test suite, of course. But, we are just playing around with building a stack. Or, we don&#39;t really know how to work with a testing framework. Or, lots of different reasons. What to do?</p>

<p>Let&#39;s go back to the core of testing. We run the script, look at the output and compare it to our mental checklist. AHA! Let&#39;s just make the computer do that. Using the standard &quot;programming by wishful thinking&quot; methodology, let&#39;s rewrite our test to look like this.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">  stack = Stack.new
  assert_equal 0, stack.size, &quot;New stack should have no elements&quot;
</code></pre></div>
<p>Do you need anything fancy to run this? Not really, you just need a method to compare the two values. So, when in doubt, or you want a quick way to run some automated tests, just give yourself the following method:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">def assert_equal(expected, actual, message)
  if expected != actual
    raise &quot;Expected #{expected}, got #{actual}\n#{message}&quot;
  end
end
</code></pre></div>
<p>This simple method can help you quickly get up and running, allowing you to focus on the problem your solving, rather than the possible complexities of a testing framework.</p>

<p>So, the next time you are playing around, or learning a new language, or teaching someone the idea of automated testing, ask yourself if you need anything more than this simple method and hold off on bringing in something larger.</p>

<p>Thanks to <a href="https://twitter.com/fablednet">Sarah Gray</a> for proof-reading this post.</p>
