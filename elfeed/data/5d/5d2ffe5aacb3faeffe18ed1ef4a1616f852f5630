<p>One of the clear benefits of functional programming is composability. It’s easy to take fundamental operations like maps, filters, and folds, and build up computations that are both powerful and concise. But sometimes concision can come at the expense of readability.</p>

<p>This Ruby code creates a data structure that is used to generate the next word in a Markov Chain based upon input text.  It’s short and sweet, but also more than a little opaque.</p>
<div class="highlight"><pre><span class="n">stems</span> <span class="o">=</span> <span class="n">ARGF</span><span class="p">.</span><span class="n">read</span><span class="p">.</span><span class="n">split</span><span class="p">.</span><span class="n">each_cons</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="n">group_by</span> <span class="p">{</span><span class="o">|</span><span class="n">word_pair</span><span class="o">|</span> <span class="n">word_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">}</span>
</pre></div>
<p>I’ll walk you through it. </p>

<ul>
<li>The first thing that we do is take a list of files from the command-line and concatenate their contents into a single string as they are being read - the <code>read</code> function on <code>ARGF</code> does this. </li>
<li>The <code>split</code> function on strings produces an array of whitespace delimited strings (let’s call them words) from the string we just produced. </li>
<li>Our use of the <code>each_cons</code> function gives us each word paired with its successor. For example, if we start with <code>[“The”, “rain”, “in”, “spain.”]</code>, an <code>each_cons</code> of 2 will produce a list of those pairs <code>[[“The”, “rain”],[“rain”,”in”],[“in”,”spain.”]]</code>.</li>
<li>Our call to <code>group_by</code> produces a hash with the first element of the pairs as the key. The value for each key is a list of all of the pairs that have that key as the first element.</li>
</ul>

<p>We are doing a lot of work in that single line of code. If we understand how each of these functions work, we can decipher it easily, but it would be nice if we had a bit more documentation.</p>

<p>In Haskell and F#, programmers often use type signatures to help readers “see” the data structures they are producing and consuming.  Every function can have an annotation that shows the structure of its interface. The only downside is that we have to break up concise chains of computation in order to in order to have those documentable functions.</p>

<p>Another avenue we can take is to introduce explaining variables so that we can name our intermediate results.</p>
<div class="highlight"><pre><span class="n">text</span> <span class="o">=</span> <span class="n">ARGF</span><span class="p">.</span><span class="n">read</span>
<span class="n">words</span> <span class="o">=</span> <span class="n">text</span><span class="p">.</span><span class="n">split</span>
<span class="n">word_pairs</span> <span class="o">=</span> <span class="n">words</span><span class="p">.</span><span class="n">each_cons</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
<p>This is ok but we are still breaking up our computation far too finely.</p>

<p>Recently, I’ve been adopting another tack. I have a function in Ruby that I call <code>c</code>. I’ve added it to the <code>Kernel</code> module.  Essentially, it is a no-op that merely returns <code>self</code> and swallows a string.  Here’s how I use it.</p>
<div class="highlight"><pre><span class="n">stems</span> <span class="o">=</span> <span class="n">ARGF</span>
  <span class="p">.</span><span class="n">read</span>                   <span class="p">.</span><span class="n">c</span><span class="p">(</span><span class="err">&#39;</span><span class="n">all</span> <span class="n">text</span><span class="err">&#39;</span><span class="p">)</span>
  <span class="p">.</span><span class="n">split</span>                  <span class="p">.</span><span class="n">c</span><span class="p">(</span><span class="err">&#39;</span><span class="n">space</span> <span class="n">delimited</span> <span class="s">&quot;words&quot;</span><span class="err">&#39;</span><span class="p">)</span>
  <span class="p">.</span><span class="n">each_cons</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>           <span class="p">.</span><span class="n">c</span><span class="p">(</span><span class="err">&#39;</span><span class="n">successive</span> <span class="n">word</span> <span class="n">pairs</span><span class="err">&#39;</span><span class="p">)</span>
  <span class="p">.</span><span class="n">group_by</span> <span class="p">{</span><span class="o">|</span><span class="n">e</span><span class="o">|</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]}</span>    <span class="p">.</span><span class="n">c</span><span class="p">(</span><span class="err">&#39;</span><span class="n">lists</span> <span class="n">of</span> <span class="n">word</span> <span class="n">pairs</span> <span class="n">by</span> <span class="n">leading</span> <span class="n">words</span><span class="err">&#39;</span><span class="p">)</span>
</pre></div>
<p>Superficially, it doesn’t seem that there is any advantage to do thing this over having explaining variables, but there is.  We can use <code>c</code> as a hook to log or display intermediate data structures for a piece of code.  I do this by introducing a wrapper when I want the insight:</p>
<div class="highlight"><pre><span class="n">show</span> <span class="k">do</span>
  <span class="n">stems</span> <span class="o">=</span> <span class="n">ARGF</span>
    <span class="p">.</span><span class="n">read</span>                   <span class="p">.</span><span class="n">c</span><span class="p">(</span><span class="err">&#39;</span><span class="n">all</span> <span class="n">text</span><span class="err">&#39;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">split</span>                  <span class="p">.</span><span class="n">c</span><span class="p">(</span><span class="err">&#39;</span><span class="n">space</span> <span class="n">delimited</span> <span class="s">&quot;words&quot;</span><span class="err">&#39;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">each_cons</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>           <span class="p">.</span><span class="n">c</span><span class="p">(</span><span class="err">&#39;</span><span class="n">successive</span> <span class="n">word</span> <span class="n">pairs</span><span class="err">&#39;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">group_by</span> <span class="p">{</span><span class="o">|</span><span class="n">e</span><span class="o">|</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]}</span>    <span class="p">.</span><span class="n">c</span><span class="p">(</span><span class="err">&#39;</span><span class="n">lists</span> <span class="n">of</span> <span class="n">word</span> <span class="n">pairs</span> <span class="n">by</span> <span class="n">leading</span> <span class="n">words</span><span class="err">&#39;</span><span class="p">)</span>
<span class="n">end</span>
</pre></div>
<p>The <code>show</code> method temporarily overrides <code>c</code> so that it shows comment text we pass it as well as the current value of <code>self</code> (usually an array or an enumeration). I’m essentially using <code>c</code> as a lightweight <code>Object#tap</code>. Insight achieved.</p>

<p>I don’t claim that this is a perfect scheme or something that would fit everyone’s taste, but I’ve found it useful.</p>
