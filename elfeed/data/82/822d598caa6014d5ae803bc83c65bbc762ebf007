
<p class = 'original'><a href = 'http://martinfowler.com/bliki/Retread.html'>Retread</a> of post orginally made on 08 Mar 2004</p>

<p>Many debates in software development are underpinned by whether
the speaker has a <a href="http://martinfowler.com/bliki/DirectingAttitude.html">DirectingAttitude</a> or an
<a href="http://martinfowler.com/bliki/EnablingAttitude.html">EnablingAttitude</a>. These different attitudes affect choices
over languages, designs, tools, processes, and lots more.</p>

<p>Here's some examples of this dichotomy:</p>

<ul>
<li>A debate a while ago triggered by Joel Spolsky's post on <a href="http://www.joelonsoftware.com/items/2003/10/13.html">exceptions</a>.

He didn't like exceptions because they could be misused badly, leading
to confusing code (directing). Bill Caputo <a href="http://www.williamcaputo.com/archives/000009.html">pointed
out</a> that exceptions, when used well, make life much easier
(enabling).</li>

<li>Some of the static/dynamic typing debate brings up these
points. Some arguments in favor of static typing talk about how they
prevent people from making certain kinds of mistake (directing) while
dynamic typers point out how static typing restricts some useful
idioms (enabling).</li>

<li>Agile processes are <a href="http://martinfowler.com/bliki/PeopleOriented.html">PeopleOriented</a> (enabling),
while plan-driven methods seek to ensure that even a poor team can do
an acceptable job (directing).</li>
</ul>

<p>These aren't hard-wired attitudes. Often people are directing in
some cases and enabling in others. But I think there is a deep strain
running through here, often a personality issue, that runs underneath
much discussion on how we do software. (I'm very much in the enabling
category, as if you can't tell.)</p>

<p>You might think that all restrictions on what a developer does
imply a directing attitude, but it's not that simple. As an example,
consider memory management. You can think of this as a directing
feature: programmers can't be trusted to manage memory correctly so
take away their ability to allocate memory. But I look at memory
management as an enabling technology - it takes away something I don't
<i>want</i> to worry about, so I can concentrate better on those
things I do care about. Steve <a href="http://stevef.truemesh.com/archives/000206.html">tied this thought nicely</a> onto the
difference between problems and difficulties.</p>

<p class="repost">reposted on 11 Mar 2014</p>

<p class="shares"><span class="label">Share: </span><a href="https://twitter.com/intent/tweet?url=http://martinfowler.com/bliki/SoftwareDevelopmentAttitude.html&amp;text=Bliki: SoftwareDevelopmentAttitude" title="Share on Twitter"><img src="/t_mini-a.png"/></a><a href="https://facebook.com/sharer.php?u=http://martinfowler.com/bliki/SoftwareDevelopmentAttitude.html" title="Share on Facebook"><img src="/fb-icon-20.png"/></a><a href="https://plus.google.com/share?url=http://martinfowler.com/bliki/SoftwareDevelopmentAttitude.html" title="Share on Google Plus"><img src="/gplus-16.png"/></a></p>
