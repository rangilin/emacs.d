<p>Yesterday, my pairing partner and I came across an interesting situation. The feature we were working on required receiving some data, constructing a date range (a year, for example), and then filtering that data through that range to see which ones fell within that range.</p>

<p>A simple example to demonstrate this:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">dates_sample_one</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">person_1</span><span class="p">:</span> <span class="no">Date</span><span class="o">.</span><span class="n">today</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> 
                     <span class="ss">person_2</span><span class="p">:</span> <span class="no">Date</span><span class="o">.</span><span class="n">today</span><span class="p">,</span> 
                     <span class="ss">person_3</span><span class="p">:</span> <span class="no">Date</span><span class="o">.</span><span class="n">today</span> <span class="o">+</span> <span class="mi">366</span><span class="p">,</span> 
                     <span class="ss">person_4</span><span class="p">:</span> <span class="no">Date</span><span class="o">.</span><span class="n">today</span> <span class="o">+</span> <span class="mi">95</span><span class="p">,</span> 
                     <span class="ss">person_5</span><span class="p">:</span> <span class="no">Date</span><span class="o">.</span><span class="n">today</span> <span class="o">+</span> <span class="mi">400</span> <span class="p">}</span>

<span class="k">def</span> <span class="nf">filter_dates_with_include</span><span class="p">(</span><span class="n">dates</span><span class="p">)</span>
  <span class="n">dates</span><span class="o">.</span><span class="n">select</span> <span class="k">do</span> <span class="o">|</span><span class="n">person</span><span class="p">,</span> <span class="n">date</span><span class="o">|</span>
    <span class="p">(</span><span class="no">Date</span><span class="o">.</span><span class="n">today</span><span class="o">.</span><span class="n">.</span><span class="no">Date</span><span class="o">.</span><span class="n">today</span> <span class="o">+</span> <span class="mi">365</span><span class="p">)</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">filter_dates_with_include</span><span class="p">(</span><span class="n">dates_sample_one</span><span class="p">)</span>
<span class="c1">#=&gt; { person_1, person_2, ... }</span>
</code></pre></div>
<p>The above example is fairly simple: Five people with different dates, some that go beyond a year and others that fall within the year. The method has a fixed range of one year, starting from the current date, and checks if the dates coming through fall within that year. Something like the above will work fine for situations in which the data set is fairly small and the calculation is fairly simple. But once you&#39;re dealing with a decent amount of data, then you have a problem.</p>

<p>To show this, I&#39;ll use Ruby&#39;s <a href="http://www.ruby-doc.org/stdlib-1.9.3/libdoc/benchmark/rdoc/Benchmark.html#method-c-bm">Benchmark module</a> and increase the data pool:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">&#39;benchmark&#39;</span>

<span class="n">dates_sample_one</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">person_1</span><span class="p">:</span> <span class="no">Date</span><span class="o">.</span><span class="n">today</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span>
                     <span class="ss">person_2</span><span class="p">:</span> <span class="no">Date</span><span class="o">.</span><span class="n">today</span><span class="p">,</span>
                     <span class="ss">person_3</span><span class="p">:</span> <span class="no">Date</span><span class="o">.</span><span class="n">today</span> <span class="o">+</span> <span class="mi">366</span><span class="p">,</span>
                     <span class="ss">person_4</span><span class="p">:</span> <span class="no">Date</span><span class="o">.</span><span class="n">today</span> <span class="o">+</span> <span class="mi">95</span><span class="p">,</span>
                     <span class="ss">person_5</span><span class="p">:</span> <span class="no">Date</span><span class="o">.</span><span class="n">today</span> <span class="o">+</span> <span class="mi">400</span> <span class="p">}</span>

<span class="n">dates_sample_two</span> <span class="o">=</span> <span class="p">{}</span>

<span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">730</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span><span class="o">.</span><span class="n">shuffle</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">days</span><span class="o">|</span>
  <span class="n">dates_sample_two</span><span class="o">[</span><span class="s2">&quot;person_</span><span class="si">#{</span><span class="n">days</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">]</span> <span class="o">=</span> <span class="no">Date</span><span class="o">.</span><span class="n">today</span> <span class="o">+</span> <span class="n">days</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">filter_dates_with_include</span><span class="p">(</span><span class="n">dates</span><span class="p">)</span>
  <span class="n">dates</span><span class="o">.</span><span class="n">select</span> <span class="k">do</span> <span class="o">|</span><span class="n">person</span><span class="p">,</span> <span class="n">date</span><span class="o">|</span>
    <span class="p">(</span><span class="no">Date</span><span class="o">.</span><span class="n">today</span><span class="o">.</span><span class="n">.</span><span class="no">Date</span><span class="o">.</span><span class="n">today</span> <span class="o">+</span> <span class="mi">365</span><span class="p">)</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># Benchmarking both</span>
<span class="c1"># this will probably vary a little bit but this is the output I got</span>

<span class="no">Benchmark</span><span class="o">.</span><span class="n">bm</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
  <span class="n">x</span><span class="o">.</span><span class="n">report</span> <span class="p">{</span> <span class="n">filter_dates_with_include</span><span class="p">(</span><span class="n">dates_sample_one</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
<span class="c1">#=&gt;            user     system      total        real</span>
<span class="c1">#=&gt; times:  0.000000   0.000000   0.000000 (  0.002043) # measured in seconds</span>


<span class="no">Benchmark</span><span class="o">.</span><span class="n">bm</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
  <span class="n">x</span><span class="o">.</span><span class="n">report</span> <span class="p">{</span> <span class="n">filter_dates_with_include</span><span class="p">(</span><span class="n">dates_sample_two</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
<span class="c1">#=&gt;   user     system      total        real</span>
<span class="c1">#=&gt; 0.040000   0.000000   0.040000 (  0.040604)</span>
</code></pre></div>
<p>Here, the second batch is made out of 40 random dates. When running the benchmark, the impact on the performance is clear: It&#39;s nearly 20 times slower, and that&#39;s just 40 records.</p>

<h3>Include vs. Cover</h3>

<p>As it was made obvious in the example above, using <code>include?</code> can be quite costly. When we ran the code, it was taking quite a while to load the pageâ€”but our assumption at the time was that there could be an issue with the API we were hitting in order to get the data. However, after running the tests, it became obvious that the problem was elsewhere.</p>

<p>The <a href="http://www.ruby-doc.org/core-2.1.2/Range.html#method-i-include-3F">explanation</a> of the <code>include?</code> method in the Range module states: <em>&quot;Returns true if obj is an element of the range, false otherwise.&quot;</em> In other words, when you ask whether an element is in a range, the include? method will check that element against each entry of the range. If it finds it, then it will stop at the point where it found the element and won&#39;t proceed with the search. The problem with this is that in situations where the element is not within the range, it will go through the whole range checking each element. Efficiency fail.</p>

<p>After getting quite frustrated with the slow tests, a friend asked if we were using <code>cover?</code>. After checking the <a href="http://www.ruby-doc.org/core-2.1.2/Range.html#method-i-cover-3F">documentation</a>, we realised that this was definitely the choice we should have been using. What <code>cover?</code> will do is take the beginning and the end of a range, and check them against the given date. Below is an example in which the end of the range is also included in the range (see <a href="http://www.ruby-doc.org/core-2.1.2/Range.html#method-i-exclude_end-3F">exclude_end?</a>):</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">date_to_check</span> <span class="o">=</span> <span class="no">Date</span><span class="o">.</span><span class="n">today</span> <span class="o">+</span> <span class="mi">30</span>
<span class="no">Date</span><span class="o">.</span><span class="n">today</span> <span class="o">&lt;=</span> <span class="n">date_to_check</span> <span class="o">&amp;&amp;</span> <span class="n">date_to_check</span> <span class="o">&lt;=</span> <span class="no">Date</span><span class="o">.</span><span class="n">today</span> <span class="o">+</span> <span class="mi">365</span>
<span class="c1">#=&gt; true</span>
</code></pre></div>
<p>This is definitely way more efficient than include, but I will let the data do the talking:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># Running the same benchmarks but with cover instead</span>

<span class="k">def</span> <span class="nf">filter_dates_with_cover</span><span class="p">(</span><span class="n">dates</span><span class="p">)</span>
  <span class="n">dates</span><span class="o">.</span><span class="n">select</span> <span class="k">do</span> <span class="o">|</span><span class="n">person</span><span class="p">,</span> <span class="n">date</span><span class="o">|</span>
    <span class="p">(</span><span class="no">Date</span><span class="o">.</span><span class="n">today</span><span class="o">.</span><span class="n">.</span><span class="no">Date</span><span class="o">.</span><span class="n">today</span> <span class="o">+</span> <span class="mi">365</span><span class="p">)</span><span class="o">.</span><span class="n">cover?</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">Benchmark</span><span class="o">.</span><span class="n">bm</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
  <span class="n">x</span><span class="o">.</span><span class="n">report</span> <span class="p">{</span> <span class="n">filter_dates_with_cover</span><span class="p">(</span><span class="n">dates_sample_one</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
<span class="c1">#=&gt;            user     system      total        real</span>
<span class="c1">#=&gt; times:  0.000000   0.000000   0.000000 (  0.000055)</span>


<span class="no">Benchmark</span><span class="o">.</span><span class="n">bm</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
  <span class="n">x</span><span class="o">.</span><span class="n">report</span> <span class="p">{</span> <span class="n">filter_dates_with_cover</span><span class="p">(</span><span class="n">dates_sample_two</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
<span class="c1">#=&gt;   user     system      total        real</span>
<span class="c1">#=&gt; 0.040000   0.000000   0.040000 (  0.000181) # Over 200 times faster than include!</span>
</code></pre></div>
<p>Knowing the above will definitely make me think twice with regard to the choices I make. It&#39;s certainly easy to fall into the trap of following what seems to be the right choice. Having things like the Benchmark module help with measuring each decision. It&#39;s all nice and beautiful when talking about the options and writing them down; but at the end of the day, numbers rule.</p>
