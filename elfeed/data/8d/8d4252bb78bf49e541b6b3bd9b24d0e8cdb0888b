<div><p>One of the most common &quot;moves&quot; as a software designer is to take what was one element and divide into two or more connected elements. (I&#039;ll write about why this is more common than the converse, coalescing elements, as soon as I figure it out.) Some separations are helpful and others are not. Here is a framework for evaluating partition decisions.</p><p><br /></p><p>On one axis we have whether the design is partitioned: is the logic broken into subroutines? Is the object broken into helper objects? Is the service broken into sub-services? On the other axis we have whether the elements can be reasoned about separately--is the performance-critical portion of the logic localized? Are side effects contained within an element?</p><p><br /></p><span class="photo "><img class="photo_img img" alt="" src="https://fbcdn-sphotos-h-a.akamaihd.net/hphotos-ak-xpf1/v/t34.0-12/s720x720/10508260_10152546763328675_428786998_n.jpg?oh=640db106173bc1d57a50d693df991ec5&amp;oe=540C71FD&amp;__gda__=1410116918_cb799230620e3d2213d496a1ced274f8" title="" /></span><br /><br />On the top left we have the &quot;modular&quot; design. We have divided the element and now when we want to reason about performance or reliability or proposed changes we can look at one element and ignore the other. Winning.<br /><br />On the bottom right is a big element, but one which we must reason about as a whole. Since we have to reason about it as a whole, though, it&#039;s better to keep it in one place. Who knows, maybe the next shower will deliver the insight we need to partition it?<br /><br />On the bottom left is an element that could be partitioned but wasn&#039;t. Every time we change it we pay the price. We have to look around to see what subset needs to be changed and then we have to look around again to (fallibly) figure out what unanticipated side effects we may have caused.<br /><br />On the top right is the worst situation, an element that needs to be reasoned about a whole that has been split. You see this with functions where the author has clearly been given a line limit. &quot;Okay, these 50 lines go here and those 50 go there.&quot; Now the price of change goes even higher. You have to figure out if one or both elements need to be modified and you have to understand their (irrational) relationship.<br /><br />I&#039;ve been writing about the static structure of the program, but the same framework applies to time. Implementing and deploying this bit now and the rest later is a partitioning decision too. I suppose the framework even applies to partitioning a change into diffs--you have diffs that can be reasoned about alone, diffs that have subparts that could be reasoned about separately, and (worst of all) multiple diffs that have to be reasoned about together.<br /><br />What requires reasoning is fluid. Introducing a new abstraction can eliminate the need to reason about a topic. Take data fetching: a single threaded language may force you to coalesce data fetching so you can efficiently batch fetches. Introducing cooperative multi-tasking can largely eliminate the need to reason about data fetching, freeing you to reorganize the code along other lines.</div>