<p>This article concludes my series about <a href="/2014/03/12/font-locking-in-emacs.html">Font Locking in Emacs</a> by illustrating how to hook into Emacs’ syntactic analyses to implement context-sensitive fontification. If you are new to this series, you may want to read the previous articles on <a href="/2014/03/12/syntactic-fontification-in-emacs.html">Syntactic Fontification in Emacs</a> and <a href="/2014/03/26/search-based-fontification-with-keywords.html">Search-based fontification with keywords</a>.</p>
<p>Context-sensitive fontification lets modes fontify text based on its syntactic context. In Puppet Mode we use this technique to fontify <a href="https://docs.puppetlabs.com/puppet/latest/reference/lang_datatypes.html#double-quoted-strings">variable interpolations in double-quoted strings</a>. In this article we’ll outline the implementation of this feature, which we originally stole from the built-in Ruby Mode.</p>
<h1 id="understanding-the-problem">Understanding the problem</h1>
<p>For this feature we cannot just use the standard <a href="/2014/03/26/search-based-fontification-with-keywords.html">font-lock-keywords</a>, because we do not have access to the syntactic context during fontification. We could match the syntax of string interpolations with a corresponding regular expression, but we cannot determine whether the interpolation occurred in a double-quoted string or not, i.e. whether the interpolation is valid and should be fontified or not.</p>
<p>To obtain this information, we need to hook into Emacs’ syntactic analyses which runs before fontification. At this stage we have full access to Emacs’ parser state which tells us whether a given position in a buffer is inside a string, so we can search for variable interpolations and determine whether they occur in a double-quoted string or not. We cannot immediately fontify interpolations, though, simply because fontification has not yet started.</p>
<p>Instead, we need store the syntactic context in a text property at each variable interpolation in a buffer. In <code>font-lock-keywords</code> we can then access this text property, and fontify valid interpolations accordingly.</p>
<h1 id="hooking-into-syntactic-analyses">Hooking into syntactic analyses</h1>
<p>To hook into syntactic analyses, we use a custom <a href="http://doc.endlessparentheses.com/Var/syntax-propertize-function"><code>syntax-propertize-function</code></a>. This function is actually intended to let major modes put <a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Properties.html#Syntax-Properties">Syntax Properties</a> onto text, in order to override and refine the static classification from the syntax table, but it can be used to run arbitrary code during syntactic analyses as well.</p>
<p>We register our custom function in the major mode definition:</p>
<div class="highlight"><pre><span class="p">(</span><span class="nv">define-derived-mode</span> <span class="nv">puppet-mode</span> <span class="nv">prog-mode</span> <span class="s">&quot;Puppet&quot;</span> <span class="p">()</span>
  <span class="c1">;; …</span>
  <span class="p">(</span><span class="nb">set</span> <span class="p">(</span><span class="nv">make-local-variable</span> <span class="ss">&#39;syntax-propertize-function</span><span class="p">)</span>
       <span class="nf">#&#39;</span><span class="nv">puppet-syntax-propertize-function</span><span class="p">)</span>
  <span class="c1">;; …</span>
<span class="p">)</span>
</pre></div>

<p><code>puppet-syntax-propertize-function</code> will now be called during syntactic analyses. In this function we search for variable interpolations in the buffer:</p>
<div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">puppet-syntax-propertize-function</span> <span class="p">(</span><span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">case-fold-search</span> <span class="no">nil</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">goto-char</span> <span class="nv">start</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">remove-text-properties</span> <span class="nv">start</span> <span class="nv">end</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">puppet-interpolation</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">funcall</span>
     <span class="p">(</span><span class="nv">syntax-propertize-rules</span>
      <span class="p">((</span><span class="nv">rx</span> <span class="p">(</span><span class="nb">or</span> <span class="nv">line-start</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nv">any</span> <span class="s">&quot;\\&quot;</span><span class="p">)))</span>
           <span class="p">(</span><span class="nv">zero-or-more</span> <span class="s">&quot;\\\\&quot;</span><span class="p">)</span>
           <span class="p">(</span><span class="nv">group</span> <span class="s">&quot;${&quot;</span>
                  <span class="p">(</span><span class="nv">optional</span> <span class="s">&quot;::&quot;</span><span class="p">)</span>
                  <span class="p">(</span><span class="nv">zero-or-more</span> <span class="p">(</span><span class="nv">any</span> <span class="s">&quot;a-z&quot;</span><span class="p">)</span>
                                <span class="p">(</span><span class="nv">zero-or-more</span>
                                 <span class="p">(</span><span class="nv">any</span> <span class="s">&quot;A-Z&quot;</span> <span class="s">&quot;a-z&quot;</span> <span class="s">&quot;0-9&quot;</span> <span class="s">&quot;_&quot;</span><span class="p">))</span>
                                <span class="s">&quot;::&quot;</span><span class="p">)</span>
                  <span class="p">(</span><span class="nv">one-or-more</span> <span class="p">(</span><span class="nv">any</span> <span class="s">&quot;A-Z&quot;</span> <span class="s">&quot;a-z&quot;</span> <span class="s">&quot;0-9&quot;</span> <span class="s">&quot;_&quot;</span><span class="p">))</span> <span class="s">&quot;}&quot;</span><span class="p">))</span>
       <span class="p">(</span><span class="mi">0</span> <span class="p">(</span><span class="k">ignore</span> <span class="p">(</span><span class="nv">puppet-syntax-propertize-interpolation</span><span class="p">)))))</span>
     <span class="nv">start</span> <span class="nv">end</span><span class="p">)))</span>
</pre></div>

<p>Since variable names are case-sensitive in Puppet, we ensure that our regular expression is case-sensitive as well by <code>let</code>-binding <code>case-fold-start</code> accordingly. Then we navigate to the start of the region being analysed, and clear state that we stored in previous analyses, by removing all occurrences of the <code>puppet-interpolation</code> property.</p>
<p>Eventually we search for variable interpolations in the region being analysed. We conveniently avoid the tedious way of calling <code>re-search-forward</code> in a <code>while</code> loop and instead abuse a little utility macro named <a href="http://doc.endlessparentheses.com/Fun/syntax-propertize-rules"><code>syntax-propertize-rules</code></a><a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>. At the first glance, this looks a little strange.</p>
<p><a href="http://doc.endlessparentheses.com/Fun/syntax-propertize-rules"><code>syntax-propertize-rules</code></a> does not do any work on its own, but instead <em>generates</em> and returns at macro expansion time a function that processes a buffer according to the given rules. Hence, we need to make an explicit function call by placing a <code>funcall</code> expression around <code>syntax-propertize-rules</code>.</p>
<p>The argument to <code>syntax-propertize-rules</code> is a list of rules, each consisting of a regular expression to search for, and a Emacs Lisp expression supposed to return the value for the <code>syntax-table</code> text property of the matched text.</p>
<p>However, we are not actually interested in changing this property. Our rule serves a different purpose: We want process each occurrence of a variable interpolation to inspect and store the syntactic context for later use during fontification.</p>
<p>Hence, our rule searches for variable interpolations and simply calls another function named <code>puppet-syntax-propertize-interpolation</code>, carefully placing an <code>ignore</code> around the function call to avoid that the return value of the function accidentally leaks into the <code>syntax-table</code> text property, thus messing up syntactic analyses.</p>
<p>Like in our <a href="/2014/03/26/search-based-fontification-with-keywords.html">previous post</a> we use <a href="http://doc.endlessparentheses.com/Fun/rx"><code>rx</code></a> to write readable regular expressions. The expression reflects a simplified variant of <a href="https://docs.puppetlabs.com/puppet/latest/reference/lang_datatypes.html#double-quoted-strings">variable interpolation</a>. It does not match all possible syntactic variants of interpolations, but fur the purpose of this post it is totally sufficient. The expression actually used in Puppet Mode is a little more intricate though.</p>
<h1 id="inspecting-the-syntactic-context">Inspecting the syntactic context</h1>
<p><code>puppet-syntax-propertize-interpolation</code> will now called during syntactic analyses, for each occurrence of a variable interpolation throughout the buffer. In this function, we have access to the syntactic context <em>and</em> to the match data of our regular expression, and can proceed to inspect the syntactic context:</p>
<div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">puppet-syntax-propertize-interpolation</span> <span class="p">()</span>
  <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">beg</span> <span class="p">(</span><span class="nv">match-beginning</span> <span class="mi">0</span><span class="p">))</span>
         <span class="p">(</span><span class="nv">context</span> <span class="p">(</span><span class="nv">save-excursion</span> <span class="p">(</span><span class="nv">save-match-data</span> <span class="p">(</span><span class="nv">syntax-ppss</span> <span class="nv">beg</span><span class="p">)))))</span>
    <span class="p">(</span><span class="nv">put-text-property</span> <span class="nv">beg</span> <span class="p">(</span><span class="nb">1+</span> <span class="nv">beg</span><span class="p">)</span> <span class="ss">&#39;puppet-interpolation</span>
                       <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">nth</span> <span class="mi">3</span> <span class="nv">context</span><span class="p">)</span> <span class="p">(</span><span class="nv">match-data</span><span class="p">)))))</span>
</pre></div>

<p>We take the relevant part of syntactic context at the beginning of the matched variable interpolation, and store it in the <code>puppet-interpolation</code> text property, together with the original match data, for later use during fontification.</p>
<p><a href="http://doc.endlessparentheses.com/Fun/syntax-ppss"><code>syntax-ppss</code></a> gives us the entire syntactic context, as a <a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Parser-State.html">fairly intricate list</a> with various properties obtained from analysing the current buffer with the current syntax table. For our purposes, we just need to know whether the interpolation is inside a string and what kind of string it occurred in. This information is available at the 4th element of the syntactic context, which holds the delimiter character of the string the given position is in, or <code>nil</code> if the position is outside of a string.</p>
<p>Since <code>syntax-ppss</code> can move the point and modify the match data, we carefully wrap the call in <code>save-excursion</code> and <code>save-match-data</code> respectively, to avoid tainting the global state.</p>
<p>By storing the match data along with the string information, we make the boundaries of the interpolation available during fontification.</p>
<h1 id="fontifying-based-on-the-syntactic-context">Fontifying based on the syntactic context</h1>
<p>To fontify the variable interpolations that we found during syntactic analyses, we make use of a special feature of <a href="http://doc.endlessparentheses.com/Var/font-lock-keywords"><code>font-lock-keywords</code></a>. In the <a href="/2014/03/26/search-based-fontification-with-keywords.html">previous article</a> we used font lock keywords with regular expressions, but font lock keywords may also use a function to match syntax.</p>
<p>Building on the <a href="/2014/03/26/search-based-fontification-with-keywords.html#setup-boilerplate">setup of the previous article</a>, we add a font lock keyword to match variable interpolations. We fontify valid variable interpolations, i.e. those that occur inside double-quoted strings, as variables:</p>
<div class="highlight"><pre><span class="p">(</span><span class="nb">defvar</span> <span class="nv">puppet-font-lock-keywords</span>
  <span class="o">`</span><span class="p">(</span>
    <span class="c1">;; …</span>
    <span class="p">(</span><span class="nv">puppet-match-interpolation</span> <span class="mi">0</span> <span class="nv">font-lock-variable-name-face</span> <span class="no">t</span><span class="p">)</span>
    <span class="c1">;; …</span>
    <span class="p">))</span>
</pre></div>

<p>The keyword starts with the <em>matcher function</em>, followed the group which to assign the face to, the face name, and a flag indicating that previous fontification should be overwritten. The latter is needed in our case, since we match interpolations <em>inside</em> strings, which were already fontified by syntactic fontification. Without this special flag, fontification would simply ignore the string contents completely.</p>
<p>A matcher function shall search for the next occurrence of the corresponding syntax construct, move the point and set the match data accordingly. Hence, we stored the match data in the previous section. If it found a match, it should return non-nil, and <code>nil</code> otherwise. Font Lock Mode calls the matcher function repeatedly until it returns <code>nil</code> and fontifies all matches.</p>
<p>In our matcher function <code>puppet-match-interpolation</code> we try to find the variable interpolations again, and restore the match data from the stored state to enable fontification:</p>
<div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">puppet-match-interpolation</span> <span class="p">(</span><span class="nv">limit</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">pos</span> <span class="p">(</span><span class="nv">next-single-char-property-change</span> <span class="p">(</span><span class="nv">point</span><span class="p">)</span> <span class="ss">&#39;puppet-interpolation</span>
                                               <span class="no">nil</span> <span class="nv">limit</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nb">and</span> <span class="nv">pos</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">pos</span> <span class="p">(</span><span class="nv">point</span><span class="p">)))</span>
      <span class="p">(</span><span class="nv">goto-char</span> <span class="nv">pos</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">value</span> <span class="p">(</span><span class="nv">get-text-property</span> <span class="nv">pos</span> <span class="ss">&#39;puppet-interpolation</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eq</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">value</span><span class="p">)</span> <span class="nv">?\&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="k">progn</span>
              <span class="p">(</span><span class="nv">set-match-data</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">value</span><span class="p">))</span>
              <span class="no">t</span><span class="p">)</span>
          <span class="p">(</span><span class="nv">puppet-match-interpolation</span> <span class="nv">limit</span><span class="p">))))))</span>
</pre></div>

<p>Instead of applying the same regular expression for interpolations again, we scan for occurrences of your special <code>puppet-interpolation</code> text property. Any such occurrence marks a variable interpolation that we found during syntactic analyses.</p>
<p>If we found an occurrence, we move the point to it and extract the value of the property. Remember that the value is a cons cell <code>(string-delimiter . match-data)</code>. By looking at <code>string-delimiter</code>, we can determine whether the interpolation occurs inside a double-quoted string. If that is the case, we restore the saved <code>match-data</code> and return <code>t</code> to indicate that our matcher function found a match.</p>
<p>Otherwise the variable interpolation occurred at no valid position, so we recursively continue to search for the next occurrence, until we hit the <code>limit</code>. If <code>next-single-char-property-change</code> reaches <code>limit</code> without finding an occurrence of the property, it returns <code>nil</code>, causing our function return <code>nil</code> as well.</p>
<h1 id="debugging">Debugging</h1>
<p>The technique that we presented in this posting is not easy to debug, since it works with in-buffer state (i.e. text properties) that is not immediately visible.</p>
<p>Fortunately, Emacs provides us with a tool to make it visible: <a href="http://doc.endlessparentheses.com/Fun/describe-char"><code>describe-char</code></a>, at <kbd>C-u C-x =</kbd>, which pops up a buffer showing the syntax classification and the text properties of the character at point. With this tool, we can now verify that our code indeed works, by checking the text properties:</p>
<div class="text-center">
<img src="/images/describe-char.png" class="img-responsive img-thumbnail">
</div>
<p>We see that our <code>puppet-interpolation</code> property exists (by pressing the <code>Show</code> button we could also check its value), and that the character was fontified with <code>font-lock-variable-name-face</code>, like we defined in <code>font-lock-keywords</code>.</p>
<h1 id="conclusion">Conclusion</h1>
<p>In this post we demonstrated an advanced approach to Emacs’ font locking, that opens up for almost infinite possibilities. In Puppet Mode, we use this technique not only for variable interpolations in double-quoted strings, but also for regular expression literals and escape sequences in strings, that would be hard to fontify correctly with <code>font-lock-keywords</code> only.</p>
<p>With this article, my series about fontification in Emacs is now at its end. I hope that it helps major mode authors to make their modes shiny, and gives interested users the knowledge and motivation to start their own major modes or contribute to Emacs projects.</p>
<p>So long</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>As in our previous posts, the actual implementation in Puppet Mode is much more intricate. In Puppet Mode we do context-sensitive fontification for other syntax as well, and we also need to place Syntax Properties at some places to account for multi-character operators, so the use of <code>syntax-propertize-rules</code> is justified by more than simply convenience.<a href="#fnref1">↩</a></p></li>
</ol>
</section>