
 
<p>Imagine, for a moment, that you came upon a bread factory for the first time. At first it just looks like a jumble of incomprehensible machinery with a few people buzzing around. As your eyes adjust you start to see little piles of things that you <em>do</em> understand. Buckets of sesame seeds. Big vats of dough. Little balls of dough. Baked loaves of bread.</p>
<p>Those things are inventory. Inventory tends to pile up between machines. Next to the machine where sesame seeds are applied to hamburger buns, there’s a big vat of...sesame seeds. At the very end of the assembly line, there are boxes and boxes of bread, waiting for trucks to drive them off to customers.</p>
<p>Keeping inventory costs money. Suppose your bakery has six 50-ton silos to store flour. Whenever they empty out, you fill them up. That means on the average day you have 150 metric tons of wheat flour in stock. At today’s prices, you’ve tied up $73,000. Forever.</p>
<p>Inventory may have other costs too, like spoilage. Flour lasts for months, but the minute bread comes out of the oven it starts dropping in value; after 24 hours it’s nearly worthless.</p>
<p><span style="display: block; margin: 0 0 0.25ex 1em; position: relative; float: right;"><a href="http://www.joelonsoftware.com/items/2012/07/09taco1.JPG"><img style="border:1px solid #666;" alt="" src="http://www.joelonsoftware.com/items/2012/07/09taco1-thumbnail.JPG" /></a></span>Why keep inventory at all? Because there are costs associated with running out of things, too. If sesame seeds take two days to order, and you run out of sesame seeds, you are out of the hamburger bun business for two days. Inventory provides a buffer that prevents any part of the process from stalling. There are modern algorithms to optimize how much buffer you need at every point (read up on Toyota’s lean production system and the Theory of Constraints to get started).</p>
<p>Why do I care about any of this? The software production process has several major “inventory” accumulation points, itself. Stuff accumulates at those points and ends up wasting a lot of time and money.</p>
<p>“What? How is software like a factory?” you ask.</p>
<p>Think of product ideas as the raw material. Depending on your process, product ideas may go through several assembly line points before they are delivered as finished features to the customer:</p>
<ol>
<li>A decision-making process (should we implement this feature?)</li>
<li>A design process (specs, whiteboards, mockups, etc)</li>
<li>An implementation process (writing code)</li>
<li>A testing process (finding bugs)</li>
<li>A debugging process (fixing bugs)</li>
<li>A deployment process (sending code to customers, putting it on web server, etc)</li></ol>
<p>(PS No, this is not “waterfall.” No it isn’t. Is <em>not. </em>Shut up.)</p>
<p>In between each of these stages, inventory can pile up. For example, when a programmer finishes implementing their code (stage 3) they give it to a tester to check (stage 4). At any given time, there is a certain amount of code waiting to be tested. That code is inventory.</p>
<p>The “cost” of code inventory is huge. It might add up to six or twelve months of work that is stuck in the assembly line and not yet in customers’ hands. This could be the difference between having a cutting-edge product (iPhone) or constantly playing catchup (Windows Phone). It’s nearly impossible to get people to buy Windows Phones, even if the iPhone is only six months better. A lot of markets have network effects, and being first has winner-take-all implications. So getting rid of inventory in the development process can make or break a product.</p>
<p>Let’s go over the three places most inventory accumulates.</p>
<p><strong>Feature backlogs.</strong> Every product attracts new feature ideas, and you can’t implement ideas as fast as you can think them up, so you write them down, and this list is called the feature backlog. A lot of the ideas on the backlog are bad ideas, and you merely wrote them down to avoid hurting the feelings of the people who thought them up. Backlogs make everyone feel good. </p>
<p>The trouble is that 90% of the things in the feature backlog will never get implemented, ever. So every minute you spent writing down, designing, thinking about, or discussing features that are never going to get implemented is just time wasted. When I hear about product teams that regularly have “backlog grooming” sessions, in which they carefully waste a tiny amount of time and mental energy every day or every week thinking about every single feature which will never be implemented, I want to poke my eyes out.</p>
<ul>
<li>Suggestion: Do not allow more than a month or two of work to get into the feature backlog list. Once the backlog is full, do not allow new items to be added unless you remove an item. Do not spend any time speccing, designing, or talking about backlog items: the backlog, in fact, should be seen as a list of things you are not allowed to talk about or work on.</li></ul>
<p><strong><span style="display: block; margin: 0 0 0.25ex 1em; position: relative; float: right;"><a href="http://www.joelonsoftware.com/items/2012/07/09taco2.JPG"><img style="border:1px solid #666;" alt="" src="http://www.joelonsoftware.com/items/2012/07/09taco2-thumbnail.JPG" /></a></span>The bug database</strong> is obviously a great thing to have. Bug reports should be complete, accurate, and actionable. But I have noticed that in many real-world companies, the desire never to miss any bug report leads to bug bankrupcy, where you wake up one day and discover that there are 3000 open bugs in the database, some of which are so old they may not apply any more, some of which can never be reproduced, and most of which are not even worth fixing because they’re so tiny. When you look closely you realize that months or years of work has gone into preparing those bug reports, and you ask yourself, how could we have 3000 bugs in the database while our product is delightful and customers love it and use it every day? At some point you realize that you’ve put too much work into the bug database and not quite enough work into the product.</p>
<ul>
<li>Suggestion: use a triage system to decide if a bug is even worth recording. </li>
<li>Do not allow more than two weeks (in fix time) of bugs to get into the bug database. </li>
<li>If you have more than that, stop and fix bugs until you feel like you’re fixing stupid bugs. Then close as “won’t fix” everything left in the bug database. Don’t worry, the severe bugs will come back.</li></ul>
<p><strong>Undeployed features.</strong> There are still a lot of teams doing quarterly or annual releases, usually because their deployment process is expensive. Operating systems, or anything where software has to be installed by every user, is usually batched up. </p>
<p>This is one of the most expensive forms of inventory: unshipped feature inventory. It could be earning you money, but it’s sitting on the shipping dock of your factory, while the guy down the street already has a product that does that exact same thing.</p>
<p>Sometimes, perniciously, you don’t even feel the pain, because everyone on your team has been dogfooding the new version for months. I’m sure everyone at Microsoft has been happily using Windows 8 for a year now, so they don’t really feel, on a day to day basis, the pain of OEMs trying to sell Windows 7 in a Mac OS X Lion world.</p>
<ul>
<li>Suggestion: Don’t let completed features pile up in ways that don’t make you money. Work on your deployment process so that you can get customers features in months rather than years. If you’re already shipping monthly, figure out how to ship weekly. Keep pushing the bar on more and more frequent deployment of smaller and smaller changes.</li></ul>
<p>So, where am I going with this? We’ve had all three kinds of inventory at Fog Creek: crazy long backlogs, overambitious bug databases, and features which got stuck for a year waiting for the next release to go out. All of these snuck up on us. I realized that we needed a system to constrain inventory so it doesn’t build up.&nbsp;</p>
<p>My original idea was to make a product called <em>Five Things</em>. It was going to be a project manager where everybody was allowed to have five things assigned to them: two things they were actively doing, one thing that was “up next”, and a couple more that they were planning. That exact design idea didn’t go anywhere (but if you want to build it, go for it), but it did evolve into <a href="http://trello.com/">Trello</a>.</p>
<p><span style="display: block; margin: 0 0 0.25ex 1em; position: relative; float: right;"><a href="https://trello.com/dev"><img style="border:1px solid #666;" alt="" src="http://www.joelonsoftware.com/items/2012/07/09trelloOnTrello-thumbnail.png" /></a></span>Trello works great for a <em>reasonable</em> amount of inventory, but it intentionally starts to get klunky if you have too many cards in one list. And that’s exactly the point: it makes inventory <em>visible</em> so that you know when it’s starting to pile up. (Click on the image at the right to see the Trello team’s own development board).</p>
<p>Every day you look at your Trello board and see that there are seventeen completed features that are totally ready to ship but which haven’t shipped for some reason, and you go find the bottleneck and eliminate it. </p>
<p>Every time somebody suggests a crazy feature idea, you look at the Feature Backlog and realize it’s just too long, so you don’t waste any time documenting or designing that crazy idea.</p>
<p>And hopefully, you’ll spend less effort working on things that never see the light of day. “Backlog grooming.” Sheeeesh.</p>
<p>Need to hire a really great programmer? Want a job that doesn't drive you crazy? Visit the <a href="http://jobs.joelonsoftware.com/">Joel on Software Job Board</a>: Great software jobs, great people.
</p>

