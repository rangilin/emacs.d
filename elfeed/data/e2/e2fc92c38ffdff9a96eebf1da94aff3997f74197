<p>One of the things that we don’t appreciate enough in software development is the way that ideas echo across the industry. I remember seeing Rich Hickey and Stu Halloway presenting Datomic and feeling palpable echoes of git’s repository model. A similar thing happened to me a while ago with microservices - I got the sense that they were an echo of Erlang.</p>

<p>About seven or eight years ago, people started rediscovering Erlang. There were quite a few conference talks and I started hearing people talk about how they were using it surreptitiously in the industry. I remember attending the 2009 ICFP conference in Edinburgh and meeting two guys who said that they had written the new chat server for Facebook in Erlang. They were both at the conference presenting it and they smiled as they mentioned that no one else at FB knew the language so if it went down while they were at the conference, well, it would be an issue.</p>

<p>At that time, people were fascinated with Erlang’s hot deployment model and its support for concurrency without threading. They were also fascinated by the fact that, the Mnesia database aside, it was, by default, a shared-nothing model. A few people, including Ralph Johnson, made the observation that Erlang processes were more like objects than what we usually see in OO - fully encapsulated and message based.</p>

<p>So now.. what is the connection to microservices? The world around microservices is in a bit of flux - people are having trouble settling on a definition that distinguishes them from SOA in any sort of a meaningful way. But, what I’m seeing is that there has been, from the beginning, an extremely strong emphasis on isolation with microservices - that shared-nothing model. From the beginning, there was the notion that you should deploy services written in multiple programming languages and that they should communicate only via web protocols across different boxes with different environments.</p>

<p>One can legitimately ask why?  In theory, programming languages give us all we need to encapsulate state and environment - we just need to use them well. </p>

<p>Maybe we just don’t have the discipline? Maybe we had to explicitly advocate the practice of writing services running in completely different environments using different languages to trigger the sort of encapsulation that we want?  If that’s the case, we can either see it as a clever self-hack or something we were forced into by the fact that we programmers are adept at overcoming any sort of self-discipline we try to impose on ourselves. </p>

<p>Perhaps both are true.</p>
