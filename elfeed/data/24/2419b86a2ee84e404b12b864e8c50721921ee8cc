<div class="_2cuy _3dgx"><div class="_2cuy _3dgx">My ability to visualize and manipulate programs has progressed over four decades of programming. People talk about the first two styles of visualization and manipulation that I use, runtime state and abstract syntax tree. Visualization and manipulation of the call graph, however, seems to be a secret.</div><div class="_2cuy _3dgx">In my first ever programming class, Professor Proskurowski insisted that we become adept at thinking like the language (Pascal, in our case). We wrote programs on the board, drew little boxes for each of the variables, and used an arrow to indicate the program counter. As we advanced the program counter we updated the values in the boxes.</div><div class="_2cuy _3dgx">This level of thinking serves me every day. When I want code to behave a certain way or I&#039;m wondering why code doesn&#039;t behave a certain way, I fall back on exactly this visualization. When performance tuning, the picture expands to include more of the architecture and its costs, but it&#039;s still the same picture.</div><div class="_2cuy _3dgx">Once I had written programs big enough to become unwieldy, I started clean things up. I noticed patterns in the cleanup which, with the advent of automated refactoring tools, became conscious rewrites of the abstract syntax tree of the program. The program went from instructions for driving state changes to being a thing in its own right that could be manipulated.</div><div class="_2cuy _3dgx">One advantage of AST rewrites is that it is relatively easy to see when you are changing the semantics of the program. This transformation, run either way, doesn&#039;t change the observed results of the program:</div><div class="_2cuy"><div class="_h2x _h2y"><div><img class="_h2z" src="https://fbcdn-sphotos-c-a.akamaihd.net/hphotos-ak-xap1/t31.0-8/q81/p640x640/10658801_10152668551903675_5695391001421909285_o.jpg" /></div><div class="_h2w _50f8 _50f4">AST rewrite that preserves semantics</div></div></div><div class="_2cuy _3dgx">Some AST changes do change the semantics of the program:</div><div class="_2cuy"><div class="_h2x _h2y"><div><img class="_h2z" src="https://fbcdn-sphotos-h-a.akamaihd.net/hphotos-ak-ash3/v/t35.0-12/p640x640/10650661_10152668507248675_411282573_o.jpg?oh=4d1fdb1bc753ae8f9f095d2b13685b0d&amp;oe=54120D5A&amp;__gda__=1410519336_a5f6b685e1f5bc7583f365962d9a8b53" /></div><div class="_h2w _50f8 _50f4">Changing semantics with an AST transformation</div></div></div><div class="_2cuy _3dgx">Sometimes I string together several AST changes. For example, if I can prove that i == 0, then I can eliminate the conditional using only AST transformations:</div><div class="_2cuy"><div class="_h2x _h2y"><div><img class="_h2z" src="https://fbcdn-sphotos-h-a.akamaihd.net/hphotos-ak-xpa1/v/t35.0-12/p640x640/10658385_10152668512263675_649124362_o.jpg?oh=47d5428b19b0a1b3dd35b9e3bcff21b4&amp;oe=5411BDFB&amp;__gda__=1410445696_30dea06379c9ce340eac3d2b9b8e1e64" /></div><div class="_h2w _50f8 _50f4">Composing refactorings</div></div></div><div class="_2cuy _3dgx">If visualizing runtime state is thesis and visualizing AST transformations is antithesis, then visualizing call graphs is synthesis. It marries runtime state and design decisions. Best to explain by example.</div><div class="_2cuy _3dgx">Suppose we are trying to eliminate some duplicate code.</div><div class="_2cuy"><div class="_h2x _h2y"><div><img class="_h2z" src="https://fbcdn-sphotos-h-a.akamaihd.net/hphotos-ak-xpa1/v/t35.0-12/p640x640/10677377_10152668539118675_2092251676_o.jpg?oh=5e5529f1fbb90a56e48614a344c5f09b&amp;oe=5411F654&amp;__gda__=1410515815_21673e565705ed3e487b9771297d06c3" /></div><div class="_h2w _50f8 _50f4">Duplicated code. Yuck!</div></div></div><div class="_2cuy _3dgx">You can treat extracting the helper method as a syntax tree transformation. What I find myself doing more often is to treat it as a manipulation of the call tree. We need a stack frame within which the repeated stuff executes.</div><div class="_2cuy"><div class="_h2x _h2y"><div><img class="_h2z" src="https://fbcdn-sphotos-h-a.akamaihd.net/hphotos-ak-prn2/v/t35.0-12/p640x640/10572905_10152668537368675_975787893_o.jpg?oh=4fe651033d8576e402c29eada06e5d94&amp;oe=54119972&amp;__gda__=1410514441_f3857ccc61894696965e006dd18e97bd" /></div><div class="_h2w _50f8 _50f4">Insert a stack frame to execute ...stuff...</div></div></div><div class="_2cuy _3dgx">Now we come to a tricky bit of call tree manipulation. We&#039;d like to include the call to increment in doStuff() but the parameters are different in f() and g(). We need the call to inc() to be in doStuff() but we need to push the constant string onto the stack in the callers (f() and g()).</div><div class="_2cuy"><div class="_h2x _h2y"><div><img class="_h2z" src="https://fbcdn-sphotos-h-a.akamaihd.net/hphotos-ak-xpf1/v/t35.0-12/p640x640/10677460_10152668535208675_836161336_o.jpg?oh=0412488825ca7fab1f583abed3efde98&amp;oe=5411D49A&amp;__gda__=1410519185_2eeb45e1841569e8ebaafbb84cf9f165" /></div><div class="_h2w _50f8 _50f4">Move the invocation of inc() down one stack frame</div></div></div><div class="_2cuy _3dgx">This is the move I don&#039;t hear anyone else talking about. What we&#039;ve done is a refactoring. It doesn&#039;t matter whether inc() gets called as the last line of doStuff() or as the line subsequent to the invocation of doStuff() (assuming we&#039;ve analyzed the control flow correctly). However, we can&#039;t explain the refactoring with AST transformations, we have to understand it as a manipulation of the call graph.</div><div class="_2cuy _3dgx">Just as I string together AST transformations to perform a big changes in small, safe steps, I string together call graph transformations to perform big changes in small safe steps--&quot;move this invocation to the caller&#039;s caller, then to the previous sibling and down a level, at which point we can safely cache its value&quot;.</div><div class="_2cuy _3dgx">These transformations are refactorings, but is there a catalog of common call tree transformations as there is for AST-based refactorings? Are there common sequences of atomic call-tree-based refactorings? Would it be possible to provide automated support to increase productivity and safety for call-tree-based refactorings? Are certain languages more amenable to call-tree-based refactorings? Does anyone else even know what I&#039;m talking about?</div></div>