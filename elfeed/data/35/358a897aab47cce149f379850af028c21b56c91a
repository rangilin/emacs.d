<div><p>A group of students apologized for &quot;not using TDD&quot; today. It was like they were apologizing to their dentist for not flossing--they should do it but just weren&#039;t motivated to take the trouble. In that moment I realized that TDD is small part of a large and complicated space. As long as the students mindfully chose where they wanted to be in the space, I didn&#039;t really care where they ended up.<br /><br />Here&#039;s the explanation I invented. I use three dimensions to characterize getting feedback for programming decisions. I think these three are the most important ones to consider, plus visualizing in three dimensions is (just barely) possible for me. Here they are:<br /><br /><span class="photo "><img class="photo_img img" alt="" src="https://fbcdn-sphotos-b-a.akamaihd.net/hphotos-ak-xpf1/v/t1.0-9/s720x720/10574406_10152569778283675_1194189633646961257_n.jpg?oh=c4c5d68b3ac7ea65db3579a79d608f65&amp;oe=5499E96B&amp;__gda__=1418395517_41c9e4d6e0cd8b2224f8df51e106b26d" title="" /></span><br /><br />One dimension to choose when seeking feedback is how much scope you are interested in. If you try to take in absolutely every potential effect of a programming decision, you would have to analyze its global economic and social impact. Scope trades off between the tactical utility of feedback and leverage. Knowing you have a syntax error means you definitely need to make changes, knowing that there might be adverse effects to society as a whole because of a decision doesn&#039;t help minute-to-minute even if it&#039;s very important.Â <br /><br /><span class="photo "><img class="photo_img img" alt="" src="https://scontent-b.xx.fbcdn.net/hphotos-xfp1/v/t1.0-9/s720x720/10557160_10152569782763675_780301244375495583_n.jpg?oh=48ef7571410849d2227e462715012cc4&amp;oe=5488180B" title="" /></span><br /><br />The second dimension characterizing programming feedback is how clear you want to be about the consequences of your decisions. Sometimes you just want to wait and see what happens, sometimes you want to predict up front exactly what you are going to see and if you see anything different at all you want to know about it unambiguously. Clarity trades off between the effort needed to specify expectations and the information produced when you have actual data to compare to the expectations.<br /><br /><b>Scope x Clarity</b><br /><br /><span class="photo "><img class="photo_img img" alt="" src="https://scontent-a.xx.fbcdn.net/hphotos-xpa1/t31.0-8/s720x720/10580828_10152569797903675_3246979180749560289_o.jpg" title="" /></span><br /><br />For TDD, I chose to get feedback at the next level above the compiler. The compiler tells you whether it&#039;s worthwhile trying to run a program. The tests (potentially) provide much more feedback about whether a program is &quot;good&quot;. A secondary effect of writing tests is that you can double-check my programming work. If you get to the same answer two different ways, you can have a fair amount of confidence that the code behaves as expected. Feedback with larger scope takes more work to gather, so test-level feedback is a reasonable tradeoff.<br /><br />On the clarity axis, for TDD I chose the full monty--binary feedback, red or green, good or trash. Not all feedback can be cast in binary terms. Reduced engagement in one part of a program can be compensated by increased engagement in another part. Analyzing subtle tradeoffs take time, though, and I was looking for feedback that wouldn&#039;t require much effort to analyze, to avoid interrupting programming flow. The combination of these two choices--complete clarity and test-level scope--defines what is conventionally called unit and integration tests:<br /><br /><span class="photo "><img class="photo_img img" alt="" src="https://scontent-a.xx.fbcdn.net/hphotos-prn1/v/t1.0-9/s720x720/10403164_10152569888783675_8959675854645288289_n.jpg?oh=a0067159cd833f586a96d8d8cba744a4&amp;oe=54831862" title="" /></span><br /><br /><span class="photo "><img class="photo_img img" alt="" src="https://fbcdn-sphotos-g-a.akamaihd.net/hphotos-ak-xpa1/v/t1.0-9/s720x720/10547543_10152569889368675_7993730858502578458_n.jpg?oh=3dd3ab2c724419ab5583d3538b5c5259&amp;oe=548C8A54&amp;__gda__=1422711979_849d0d33f3edb217e86b3dc0f8971161" title="" /></span><br /><br />The final dimension along which to choose feedback is frequency. Fortunately this can measured in a tidy linear way (even if the effects of delay are non-linear) from years to seconds (and milliseconds if you listen to Gary Bernhardt, which I do).<br /><br /><b>TDD = Frequency:seconds * Scope:tests * Clarity:binary</b><br /><br /><span class="photo "><img class="photo_img img" alt="" src="https://scontent-a.xx.fbcdn.net/hphotos-xpf1/v/t1.0-9/s720x720/10482564_10152569894088675_5713318650435333552_n.jpg?oh=171c1575e8723f4f74dd4241761994e3&amp;oe=54A288CB" title="" /></span><br /><br />TDD is a little box in this big space of feedback, the combination of expressing binary expectations, expressing them as tests, and receiving feedback every few seconds about whether those expectations are being met. This seems to me to be a sweet spot in the feedback space. You don&#039;t get perfect information, but you get pretty good information at a reasonable cost and quickly enough that you can a) fix problems quickly and b) learn not to make the same mistake again.<br /><br /><b>Consequences</b><br /><br />Expressing feedback as a space suggests experiments. What if you relaxed the frequency dimension? Would the additional scope you could cover provide enough value to make up for the reduced timeliness? What new mistakes could you catch if you reduced clarity and increased scope? How frequently should such feedback be considered? If you increase the modularity of the system, how much could you increase frequency? How long would it take for the investment in design be paid for (if ever)?<br /><br />The feedback space illustrates one of the dangers of feedback, putting the response loop inside the measurement loop. This happens when businesses manage quarter-to-quarter even though the effects of decisions aren&#039;t known for years. Technically, if you got feedback about server load every four minutes, you would be nuts to change server configuration every minute. You&#039;re just going to cause oscillation. We can label parts of the feedback space &quot;here abide dragons&quot;.<br /><br />Now I can explain when TDD doesn&#039;t matter. When the students understand the shape of feedback space, when they understand the tradeoffs involved in moving along each dimension, and when they understand the interaction of the dimensions, then I don&#039;t care if they &quot;do&quot; TDD or not. I&#039;d rather focus on teaching them the principles than policing whether they are aping one particular ritual. That&#039;s when TDD doesn&#039;t matter.</p></div>