<p><a href="https://www.docker.com">Docker</a> is something really hot recently. It allows you to run your software with <a href="https://linuxcontainers.org">linux container</a> easily. It's actually kind of OS level isolation rather than hardware simulation nor kernel simulation. So you won't have too much performance penalty but still have pretty nice virtual machine features. I really like the <a href="https://www.youtube.com/watch?v=ZzQfxoMFH0U">analog used by Docker community</a>, shipping software should be easier and Docker serves as just like the standard container in shipping industry.</p>

<div style="text-align: center">
    <img src="http://user-image.logdown.io/user/822/blog/819/post/218319/ufkpLQDnT4O9CRQE3ieH_small_v-dark.png">
</div>
<h3>Building docker images is not hard, but ...</h3>
<p>Although docker provides an easy way to deliver and run your software in linux container, there is still no an obvious and easy way to build a docker image for big projects. For building a large and complex project docker image, you would probably need to</p>

<ul>
<li>Clone your private software repo in to build folder</li>
<li>Ensure base images are built before your project image</li>
<li>Generate some files dynamiclly, such as current git commit revision</li>
<li>Generate templates</li>
<li>Upload image with your credentials </li>
</ul><p>With <a href="https://docs.docker.com/reference/builder/">Dockerfile</a>, you can only have static steps for building the image. Obviously, it was not designed for doing any of these listed above. And since docker uses a kind of <a href="http://docs.docker.com/terms/filesystem/">layering file system</a>, you probably don't want to put your Github credentials into the container and pull the repo inside it, because it works pretty similar to git commits, once you commit, then it's hard to remove it from the history. So you defititely want to do these things outside the container and then put them together. </p>
<h3>My first solution - Crane</h3>
<p>With these requirements in mind, I actually feel it's pretty similar to the experience I had with <a href="https://github.com/opscode/omnibus">Omnibus</a> - a tool for packing your software into a standalone dep package. So I built a simple tool in Python for building docker images, named <a href="https://github.com/victorlin/crane">Crane</a>. It allows you to define steps for building the image, it also provides template generating with <a href="http://jinja.pocoo.org/docs/">jinja2</a>.</p>
<h3>The final solution - ansible</h3>
<p>Crane was working fine, but I actually don't like to make a new wheel and maintain it if there is already an obvious better solution. After I played <a href="http://www.ansible.com">ansible</a> for a while, I realized it is actually a way better solution for building docker images. So, what is ansible you may ask, well, it's yet another deployment tool, like <a href="http://puppetlabs.com">Puppet</a>, <a href="http://www.getchef.com/chef/">Chef</a> or <a href="http://www.saltstack.com">SaltStack</a>.</p>

<div style="text-align: center">
    <img src="http://user-image.logdown.io/user/822/blog/819/post/218319/EC978BVCRUWtlIu96KJp_ansible_logo_black_square_small.png">
</div>

<p>Wait, what? Why you are using a deployment tool for building docker image? It may sound odd to you at very begining. But ansible is not actually just yet antoher deployment tool. Its design is pretty different from its predecessors. It uses SSH for pushing commands to target marchines, other tools are all pulling based. It also provides many modules for different operations, including creating instances in EC2 or other cloud computing providers. Most importantly, it is able to do orchestration easily.</p>

<p>Of course it meets requirements we mentioned before</p>

<ul>
<li>Clone git repo? Check. </li>
<li>Build base image? Check.</li>
<li>Generate dynamic file? Check.</li>
<li>Generate templates? Check.</li>
<li>Upload images? Check.</li>
</ul><p>Moreover, with ansible, you can launch an EC2 instance, build the image inside it, and run a series of tests before you publish the image. Or you can simply build the image in your <a href="http://www.vagrantup.com">vagrant</a> machine or in the local machine. It makes building software extremely flexible, since you can run the building process anywhere you want as long as they can be pushed as commands via SSH, you can also provision the whole building environment, or even drive a fleet in cloud for building, that's pretty awesome huh, isn't it?</p>
<h3>Show me the code</h3>
<p>Okay, enough of talking, let's see the code. The <code>tasks/main.yml</code> looks like this</p>

<figure class="figure-code code"><div class="highlight"><pre>- assert:
    that: 
      - 'hellobaby_version != ""'

- name: install apt packages
  apt: "name='{{ item }}' state=present"
  with_items:
    - git
    - python-pip

- name: install docker-py
  pip: name=docker-py version=0.3.1

- name: create build directory
  file: &gt;
    dest="{{ hellobaby_build_dir }}"
    state=directory

- name: clone hellobaby git repo
  git: &gt;
    repo="{{ hellobaby_repo }}"
    dest="{{ hellobaby_build_dir }}/hellobaby"
    version="v{{ hellobaby_version }}"
  register: hellobaby_repo

- name: remove git deploy key
  file: dest=/tmp/github_deploy_key state=absent

- name: archive repo
  shell: &gt;
    cd "{{ hellobaby_build_dir }}/{{ item }}" &amp;&amp;
    git archive -o ../{{ item }}.tar HEAD
  with_items:
    - hellobaby

- name: generate templates
  template: &gt;
    src="{{ item.src }}"
    dest="{{ hellobaby_build_dir }}/{{ item.dest }}"
  with_items:
    - { src: "Dockerfile", dest: "Dockerfile" }
    - { src: "runapp.sh", dest: "runapp.sh" }

- name: build image
  docker_image: &gt;
    name="{{ hellobaby_image_name }}"
    tag="{{ hellobaby_image_tag }}"
    path="{{ hellobaby_build_dir }}"
    state=build

- name: tag
  command: &gt;
    docker tag -f
    {{ hellobaby_image_name }}:{{ hellobaby_image_tag }}
    {{ hellobaby_image_name }}:{{ hellobaby_extra_tag }}
  when: hellobaby_extra_tag != ''
</pre></div>
</figure><p>and the playbook looks like this</p>

<figure class="figure-code code"><div class="highlight"><pre>---
- name: Build Hello baby app image
  hosts: all
  sudo: yes
  vars_prompt:
    - name: hellobaby_version
      prompt: "hellobaby_version"
      default: "1.0.0"
      private: no
    - name: hellobaby_iteration 
      prompt: "hellobaby_iteration"
      default: 1
      private: no
  roles:
    - Ansibles.apt
    - hellobaby_image
</pre></div>
</figure><p>So, to build with vagrant, you can run something like this</p>

<figure class="figure-code code"><div class="highlight"><pre>ansible-playbook \
  -i .vagrant/provisioners/ansible/inventory/vagrant_ansible_inventory \
  -u vagrant --private-key=~/.vagrant.d/insecure_private_key \
  playbooks/hellobaby.yml
</pre></div>
</figure><p>You can find the complete example here - <a href="https://github.com/victorlin/ansible-docker-demo">ansible-docker-demo</a>.</p>
<h3>A tool for deployment but also amazing for building software</h3>
<p>Although ansible was not designed for building software, it doesn't necessary mean you cannot do not it. And surprisingly, it does so well in building software. With its machine provisioning and orchestration capability, you can integrate building and deployment togehter easily. The building environment itself can also be provisioned before building the software. Cloud computing resource can also be liveraged. I feel there are actually lots more interesting things can be done with ansible. Looking forward to see how people use it not just for deployment but also for building software :P</p>