<p>Readability of code is important, there is a fact</p>

<blockquote>
<p>Code is read more than it is written</p>
</blockquote>

<p>This is so true, even when you are writing code, actually, you need to read the current code base again and again. Back to the ancient programming era, people are still using forbidden black magic - goto statements.  Powered by the black magic, there is a demond <a href="http://en.wikipedia.org/wiki/Spaghetti_code">Spaghetti code</a>, and it looks like this</p>

<p><img src="http://user-image.logdown.io/user/822/blog/819/post/143113/9EHOq5nxQeaJnsqbqlUB_Spaghetti.jpg" alt="Spaghetti.jpg"></p>

<p>(From <a href="http://en.wikipedia.org/wiki/File:Spaghetti.jpg" rel="nofollow" target="_blank">http://en.wikipedia.org/wiki/File:Spaghetti.jpg</a> under Creative Commons 2.0 license)</p>

<p>Spaghetti code is the code hard to read and maintain, it was killing countless developers. Then a brave developer invented a new form of magic - <a href="http://en.wikipedia.org/wiki/Structured_programming">structure programming</a>, eventually, the demond was defeated and the black magic was forbidden since then.</p>

<p>This story told us readability is important, but what about readability of Git commit history? There are chances we need to look into the development history, such as finding what are the corresponding ticket for those commits? Who is the author? when are the changes introduced. Although there are tools to use, sometimes you still need to read the history and it is just unreadable and hard to understand. I bet you see much worser history than this one</p>

<p><img src="http://user-image.logdown.io/user/822/blog/819/post/143113/DRGOJsWkT8EtkicOHEQJ_1ced9f18-ffeb-11e2-854a-21d3b661b672.png" alt="1ced9f18-ffeb-11e2-854a-21d3b661b672.png"></p>

<p>It makes reading painful. Despite chance of reading development history is less than reading code, it is still very helpful to have a clean readable linear history. Today, I am going to share some experience about keeping a readable history.</p>
<h3>Use SourceTree</h3>
<p>It is never pleasant to use a command line tool when there is a nice GUI tool. I hate ASCII git history graph, they are just ugly. Luckly, we have an awesome free GUI tool to use - <a href="http://www.sourcetreeapp.com">SourceTree</a>.</p>

<p><img src="http://user-image.logdown.io/user/822/blog/819/post/143113/u1LTZgYWTcWxe2zB421y_eae918a6-ffec-11e2-88a4-d6cd5858afd6.png" alt="eae918a6-ffec-11e2-88a4-d6cd5858afd6.png"></p>
<h3>Always create a new branch for ticket</h3>
<p>When you are working for an ticket or issue, you should always create a branch for it.</p>

<p><img src="http://user-image.logdown.io/user/822/blog/819/post/143113/VwCQDkXqRDWpVrMSACAm_add07604-fff0-11e2-92b6-1ac3af04ae5f.png" alt="add07604-fff0-11e2-92b6-1ac3af04ae5f.png"></p>

<p>You should try to keep commits in the branch only for resolving that ticket. It is okay to have some typo corrections or minor changes in it. However, if you put unrelative commit for major changes into the branch, other developers cannot know that you have some off topic changes in that branch easily. <br>
By doing branch only for one purpose, here you have</p>

<ul>
<li>Easier to understand what this branch is for</li>
<li>Easier to reverse changes introduced by this branch</li>
</ul><p>Here you are working on a new branch, then you can commit</p>

<p><img src="http://user-image.logdown.io/user/822/blog/819/post/143113/f2zUXOkpSHS7CbjsotLC_2ef071bc-fff1-11e2-94f7-e9e99d61f194.png" alt="2ef071bc-fff1-11e2-94f7-e9e99d61f194.png"></p>

<p>After then, you have several commits and they are good to merge</p>

<p><img src="http://user-image.logdown.io/user/822/blog/819/post/143113/gOsqHRnoSkukya2fk432_b9358abe-fff2-11e2-8bc0-45c240afd901.png" alt="b9358abe-fff2-11e2-8bc0-45c240afd901.png"></p>

<p>We want to keep the branch in history, so remember to use non-fast-forward merge, check the <code>Do not fast-forward when merging, always create commit</code> option</p>

<p><img src="http://user-image.logdown.io/user/822/blog/819/post/143113/0JK14SXgRl2c9fdJvPZu_7d245a0a-fff2-11e2-8be5-9289e6d86d8d.png" alt="7d245a0a-fff2-11e2-8be5-9289e6d86d8d.png"></p>

<p>It's time to merge, first, right click one the <code>master</code> branch and click <code>Checkout</code>. You should be at <code>master</code> branch now. Then, right click <code>new-feature</code> branch and click <code>Merge</code>.</p>

<p><img src="http://user-image.logdown.io/user/822/blog/819/post/143113/65aVdpUVQu2Fu12ncr9Y_73d9eafe-fff3-11e2-8086-799dd1e77edb.png" alt="73d9eafe-fff3-11e2-8086-799dd1e77edb.png"></p>

<p>Remember to check <code>Commit merged changes immediately</code> to make a new commit directly.</p>

<p>Whoa, here we are, a beautiful linear history still with branch information.</p>

<p><img src="http://user-image.logdown.io/user/822/blog/819/post/143113/29Ki3wh0RaakekspbedR_068000bc-fff6-11e2-9e81-641ba0e09083.png" alt="068000bc-fff6-11e2-9e81-641ba0e09083.png"></p>
<h3>Always rebase before merge</h3>
<p>For now, you are writing the next awesome feature - foobar-2000!</p>

<p><img src="http://user-image.logdown.io/user/822/blog/819/post/143113/XRTynRtBRviqFRnsbQKo_c67a7e4c-fff6-11e2-8d70-9bf3ad080a51.png" alt="c67a7e4c-fff6-11e2-8d70-9bf3ad080a51.png"></p>

<p>Things go well, however, in the mean time, a new branch is merged from other guys repo. Oh my god, foobar 3000! awesome!</p>

<p><img src="http://user-image.logdown.io/user/822/blog/819/post/143113/LiLFgsPaT3S20FsXPPJX_f6953c1a-fff7-11e2-94c3-2676b2064b0a.png" alt="f6953c1a-fff7-11e2-94c3-2676b2064b0a.png"></p>

<p>Okay, let's see what it looks like to merge it directly</p>

<p><img src="http://user-image.logdown.io/user/822/blog/819/post/143113/uHocekrSguT4zUnLmKqL_3b3b1592-fff8-11e2-889c-858a6f3c65c0.png" alt="3b3b1592-fff8-11e2-889c-858a6f3c65c0.png"></p>

<p>Ugly, let's try something better - rebase. First, right click on <code>foobar-2000</code> and click <code>checkout</code>. Then right click on <code>master</code> and click <code>Rebase</code></p>

<p><img src="http://user-image.logdown.io/user/822/blog/819/post/143113/gTbkA91CROI5XtJUCsYb_0e721cbc-fff9-11e2-99c9-4b248a38a6ea.png" alt="0e721cbc-fff9-11e2-99c9-4b248a38a6ea.png"></p>

<p>This is better! And we can merge it like before</p>

<p><img src="http://user-image.logdown.io/user/822/blog/819/post/143113/4QJXHA4SbSYBY0lcR1Zg_72b1754c-fff9-11e2-8754-a50629b3bd95.png" alt="72b1754c-fff9-11e2-8754-a50629b3bd95.png"></p>
<h3>Rebase and force push</h3>
<p>As usual, you keep work on this nice and beautiful linear history, however, you won't feel safe to leave your commits on your local machine will you? We always push our working branch to GitHub to keep it safe, get reviews and feedbacks from others</p>

<p><img src="http://user-image.logdown.io/user/822/blog/819/post/143113/pjkKuR2sSeeeVereCLpf_01230738-fffe-11e2-8a02-9ea6e80c50a7.png" alt="01230738-fffe-11e2-8a02-9ea6e80c50a7.png"></p>

<p>Yes, again, you may hate this, there is another branch is merged into the master.</p>

<p><img src="http://user-image.logdown.io/user/822/blog/819/post/143113/qbXln0uBT12Pf10LYXqa_d6860ede-fffe-11e2-9406-05781418eec3.png" alt="d6860ede-fffe-11e2-9406-05781418eec3.png"></p>

<p>Okay, you said, this is not a big deal, I can always rebase and merge as usual. Here you rebase</p>

<p><img src="http://user-image.logdown.io/user/822/blog/819/post/143113/iZHcjc9tQNWVqLqtysha_12799f14-ffff-11e2-9a47-e421f30877c9.png" alt="12799f14-ffff-11e2-9a47-e421f30877c9.png"></p>

<p>Well, it is still under development, you want to push to your fork, but not to merge it. Then you push, and oops!</p>

<p><img src="http://user-image.logdown.io/user/822/blog/819/post/143113/I75ooxG6RqRjOz867aet_44715750-ffff-11e2-8d0e-417ae238e6e6.png" alt="44715750-ffff-11e2-8d0e-417ae238e6e6.png"></p>

<p>So what just happened? </p>

<p>As you can see there is a branch <code>origin/foobar-bugfix</code>, that the <code>HEAD</code> in your <code>origin</code> remote, which is, your GitHub fork repo. When you are pushing your local <code>foobar-bugfix</code> to the fork repo, it means the remote one will be overwritten. It is a little bit dangerous to overwrite a HEAD in Git repo. So, it doesn't allow you to do this by default. </p>

<p>Again, it has risk, so you need to be sure what you are doing (although the commit will still stored in the repo, but without HEAD you cannot find them easily, you will need some low level operations to get them back). In this case, we just want to rebase our commits on the master and push it to our own repo, that won't be a big problem in most cases. It appears SourceTree doesn't support --force push, so you need to click <code>Terminal</code> button. Then type</p>

<figure class="figure-code code"><div class="highlight"><pre>git push origin foobar-bugfix -f
</pre></div>
</figure><p>This will force git to push your local branch to overwrite the remote one. Let's see</p>

<figure class="figure-code code"><div class="highlight"><pre>$ git push origin foobar-bugfix -f
Counting objects: 11, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (9/9), 809 bytes, done.
Total 9 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (9/9), done.
To /Users/VictorLin/foobar_fork
 + 178c9a4...cc5d760 foobar-bugfix -&gt; foobar-bugfix (forced update)
</pre></div>
</figure><p>Here we are</p>

<p><img src="http://user-image.logdown.io/user/822/blog/819/post/143113/HQJsQ5DZQsyQ0ynONF4A_c32d8b08-0000-11e3-9350-cd8bc9cb7ca4.png" alt="c32d8b08-0000-11e3-9350-cd8bc9cb7ca4.png"></p>

<p>(Tips: you can click <code>Repository</code> and <code>Refresh Remote Status</code> to update your git history status on the UI)</p>

<p><strong>Notice</strong> When you are the only one working on the branch, it is fine to do a force push, otherwise, be careful. For more details, please reference to <br><a href="http://git-scm.com/book/ch3-6.html#The-Perils-of-Rebasing" rel="nofollow" target="_blank">http://git-scm.com/book/ch3-6.html#The-Perils-of-Rebasing</a></p>
<h3>Always rebase current developing branch when there are new commits</h3>
<p>As you know, there would be conflicts when you are doing merge or rebase. When there are more new commits in the master branch, the more likely you are going to have a tons of confliction. So, it is a good practice to always rebase your working branch on the master when there are new commits on it.</p>

<p><img src="http://user-image.logdown.io/user/822/blog/819/post/143113/t2rezWJTCqWONLMQXKEJ_4727a568-0003-11e3-994d-fe37950d731b.png" alt="4727a568-0003-11e3-994d-fe37950d731b.png"></p>

<p>However, sometimes, you have some works on the branch, but they are not committed, you don't want to commit something in middle like this. But when you are doing rebase, Git won't allow you to have change to files in the workspace. In this case, you can use <code>Stash</code>. Click <code>Repository</code> and <code>Stash Changes</code>.</p>

<p><img src="http://user-image.logdown.io/user/822/blog/819/post/143113/q8GVnXQ0THuL7GmOknFQ_f1415576-0003-11e3-9654-16fb89934ea4.png" alt="f1415576-0003-11e3-9654-16fb89934ea4.png"></p>

<p>Then you can see your stash appears in the sidebar</p>

<p><img src="http://user-image.logdown.io/user/822/blog/819/post/143113/HmMp8xn2TAmGQFEx25zs_260587e6-0004-11e3-99f2-32412bf3eae6.png" alt="260587e6-0004-11e3-99f2-32412bf3eae6.png"></p>

<p>After you finish the rebasing, you can right click on the stash and click <code>Apply Stash</code>, then here you are. Your saved changes are back to working space.</p>

<p>Again, happy ending :D </p>

<p><img src="http://user-image.logdown.io/user/822/blog/819/post/143113/hu5yTbt2SEC3pB5669Gm_0ca5aa82-0005-11e3-9678-ee0b9f7b4354.png" alt="0ca5aa82-0005-11e3-9678-ee0b9f7b4354.png"></p>
<h3>Use interactive rebase to clean dirty commits</h3>
<p>People make mistake. Sometimes there are small commits which are for formatting or fixing typo. And these commits are all based on your own newly submitted commits.</p>

<p><img src="http://user-image.logdown.io/user/822/blog/819/post/143113/vx708vqCT2WI2cE4PY3J_fdd95d30-0006-11e3-8ba1-bccb8edc39f1.png" alt="fdd95d30-0006-11e3-8ba1-bccb8edc39f1.png"></p>

<p>In this case, you might wonder would it be nice to adopt some black magic to make your stupid mistakes disappear? Well, yes, there is magic. You can use interactive rebase to squash some commits into pervious one. Now, you are at <code>awesome</code> branch, right click on <code>master</code> branch, then click <code>Rebase children of xxx interactively</code>. Then you will see interface like this</p>

<p><img src="http://user-image.logdown.io/user/822/blog/819/post/143113/CX9bl8nIQRuVisXWA5Pv_8b2c2532-0007-11e3-9da6-cb3b965a02eb.png" alt="8b2c2532-0007-11e3-9da6-cb3b965a02eb.png"></p>

<p>Select those mistake fixing commits, and click <code>Squash with previous</code>. And you will see multiple commits to be put altogether. And you can click <code>Edit message</code> to modify the commit message of the squashed commit.</p>

<p><img src="http://user-image.logdown.io/user/822/blog/819/post/143113/eAygJFRbSmWIu4x4sGWK_f4c735d6-0007-11e3-84d7-b385c85671ad.png" alt="f4c735d6-0007-11e3-84d7-b385c85671ad.png"></p>

<p>Then press <code>OK</code> and look this!</p>

<p><img src="http://user-image.logdown.io/user/822/blog/819/post/143113/blOoWA1QUmXurt74WwEm_233957d2-0008-11e3-889d-7b7148e46f65.png" alt="233957d2-0008-11e3-889d-7b7148e46f65.png"></p>

<p>Just like what he said in Mad Man, nothing happened! </p>

<p>This is actually even more powerful, you can arrange order of commits around, edit commit messages, delete specific commits. But be careful, like what Spider Man told you</p>

<figure class="figure-code code"><div class="highlight"><pre>Great power comes great responsibility
</pre></div>
</figure><p>It is kind of history rewrite, it is fine to use it on the branch only you are working on, you should not use it on a shared branch unless you know exactly what you are doing.</p>
<h3>The benefits of readable history</h3>
<p>That's it, the history is linear, another wonderful day.</p>

<p><img src="http://user-image.logdown.io/user/822/blog/819/post/143113/NIFjfxnERQeTWOIr0B57_35d7c65c-0009-11e3-9dc1-12f77d3dc843.png" alt="35d7c65c-0009-11e3-9dc1-12f77d3dc843.png"></p>

<p>Readable history doeson't only look beautiful, it provides easy-to-understand development history. All team members in the project can follow the development progress easily. When something goes wrong, it is also easier to trace down the problem, especially when you need to fix it as soon as possible.  </p>