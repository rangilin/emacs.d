<p>I just had one of those &ldquo;programming made me happy&rdquo; moments I thought I&rsquo;d share.</p>

<h3>Background</h3>

<p>I&rsquo;m working on a pure-Elixir markdown parser called
<a href="https://github.com/pragdave/earmark">earmark</a>. As you probably know,
markdown is very poorly specified, which means that each
implementation wings it when it comes to edge cases.</p>

<p>Into this void comes <a href="http://standardmarkdown.com">Standard Markdown</a>,
a valiant attempt to create a specification for this most organic of
syntaxes.</p>

<p>As part of their effort, they have a test suite. It&rsquo;s written as a
pseudo-markdown document. The tests are stanzas that look like this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Here is a simple example of a blockquote:
</span><span class='line'>
</span><span class='line'>.
</span><span class='line'>&gt; # Foo
</span><span class='line'>&gt; bar
</span><span class='line'>&gt; baz
</span><span class='line'>.
</span><span class='line'>&lt;blockquote&gt;
</span><span class='line'>&lt;h1&gt;Foo&lt;/h1&gt;
</span><span class='line'>&lt;p&gt;bar
</span><span class='line'>baz&lt;/p&gt;
</span><span class='line'>&lt;/blockquote&gt;
</span><span class='line'>.
</span><span class='line'>
</span><span class='line'>The spaces after the `&gt;` characters can be omitted:
</span><span class='line'>
</span><span class='line'>.
</span><span class='line'>&gt;# Foo
</span><span class='line'>&gt;bar
</span><span class='line'>&gt; baz
</span><span class='line'>.
</span><span class='line'>&lt;blockquote&gt;
</span><span class='line'>&lt;h1&gt;Foo&lt;/h1&gt;
</span><span class='line'>&lt;p&gt;bar
</span><span class='line'>baz&lt;/p&gt;
</span><span class='line'>&lt;/blockquote&gt;
</span><span class='line'>.</span></code></pre></td></tr></table></div></figure>


<p>The lines containing just dots delimit the tests. The first block is
the markdown input, and the second block is the expected HTML output.</p>

<p>They thoughtfully provide a Perl script that runs these tests against
your markdown implementation.</p>

<p>I wanted instead to integrate their tests into my overall test
suite. This means I wanted to run their tests inside Elixir&rsquo;s ExUnit.</p>

<p>It turns out to be fairly easy. But, along the way, I learned a
little, and I smiled a lot. Here&rsquo;s a brain dump of what was involved.</p>

<h3>What I wanted to do</h3>

<p>A normal ExUnit test looks something like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="k">defmodule</span> <span class="no">HtmlRendererTest</span> <span class="k">do</span>
</span><span class='line'><span class="k">  </span><span class="kn">use</span> <span class="no">ExUnit</span><span class="o">.</span><span class="no">Case</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">test</span> <span class="s2">&quot;something&quot;</span> <span class="k">do</span>
</span><span class='line'><span class="k">    </span><span class="n">assert</span> <span class="n">my_code</span><span class="p">(</span><span class="m">123</span><span class="p">)</span> <span class="o">==</span> <span class="m">999</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">test</span> <span class="s2">&quot;something else&quot;</span> <span class="k">do</span>
</span><span class='line'><span class="k">    </span><span class="n">assert</span> <span class="n">my_code</span><span class="p">(</span><span class="m">234</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">42</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>I wanted to take the stanzas from the spec and create a new ExUnit
test for each. The name of the test would be the original markdown, so
I could easily identify failures.</p>

<h3>Top level—Checking for the spec file</h3>

<p>I only want to create the ExUnit tests if the spec file is
available. To do this, I use the fact that module definitions are
executable code. My overall structure looks like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="k">defmodule</span> <span class="no">StmdTest</span> <span class="k">do</span>
</span><span class='line'><span class="k">  defmodule</span> <span class="no">Spec</span> <span class="k">do</span>
</span><span class='line'><span class="k">    def</span> <span class="n">file</span><span class="p">,</span> <span class="k">do</span><span class="p">:</span> <span class="s2">&quot;test/spec.txt&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="no">File</span><span class="o">.</span><span class="n">exists?</span><span class="p">(</span><span class="no">Spec</span><span class="o">.</span><span class="n">file</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'>
</span><span class='line'><span class="k">    </span><span class="kn">use</span> <span class="no">ExUnit</span><span class="o">.</span><span class="no">Case</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">#&lt;&lt;&lt;</span>
</span><span class='line'>    <span class="c1">#  generate tests</span>
</span><span class='line'>    <span class="c1">#&gt;&gt;&gt;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>
</span><span class='line'>    <span class="no">IO</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;Skipping spec tests—spec.txt not found&quot;</span>
</span><span class='line'>    <span class="no">IO</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;(hint: ln -s stmd/spec.txt to spec.txt)&quot;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>The nested module <code>Spec</code> is there because I&rsquo;m going to need the spec
file name in a couple of places later, and I didn&rsquo;t want to duplicate
it.</p>

<p>The main flow here is fairly straightfoward—if the spec file exists,
we register ourselves as a test module by calling <code>use ExUnit.Case</code>
and then we create the tests. If not, we write a friendly message to
the console to tell people what to do.</p>

<h3>Generating the tests</h3>

<p>My next problem was to generate the tests—one test for each stanza in
the spec file. I assumed that I&rsquo;d be able to write code to parse the
specs, returning a list of maps, one map per test. Each map would have
two keys—<code>md</code> for the markdown and <code>html</code> for the HTML. Given this,
generating the tests looks like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="n">for</span> <span class="err">%</span><span class="p">{</span> <span class="ss">md:</span> <span class="n">md</span><span class="p">,</span> <span class="ss">html:</span> <span class="n">html</span> <span class="p">}</span> <span class="o">&lt;-</span> <span class="no">StmdTest</span><span class="o">.</span><span class="no">Reader</span><span class="o">.</span><span class="n">tests</span> <span class="k">do</span>
</span><span class='line'><span class="k">  </span><span class="nv">@md</span>   <span class="no">Enum</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="no">Enum</span><span class="o">.</span><span class="n">reverse</span><span class="p">(</span><span class="n">md</span><span class="p">))</span>
</span><span class='line'>  <span class="nv">@html</span> <span class="no">Enum</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="no">Enum</span><span class="o">.</span><span class="n">reverse</span><span class="p">(</span><span class="n">html</span><span class="p">))</span>
</span><span class='line'>  <span class="n">test</span> <span class="s2">&quot;\n--- === ---\n&quot;</span> <span class="o">&lt;&gt;</span> <span class="nv">@md</span> <span class="o">&lt;&gt;</span> <span class="s2">&quot;--- === ---\n&quot;</span> <span class="k">do</span>
</span><span class='line'><span class="k">    </span><span class="n">result</span> <span class="o">=</span> <span class="no">Earmark</span><span class="o">.</span><span class="n">to_html</span><span class="p">(</span><span class="nv">@md</span><span class="p">)</span>
</span><span class='line'>    <span class="n">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="nv">@html</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>The loop calls <code>StmdTest.Reader.tests</code> (which I haven&rsquo;t written yet)
to return a list of tests. Each entry in the list is a map containing
the markdown and the HTML. The loop uses pattern
matching to extract the fields.</p>

<p>The second and third lines of the loop are a little tricky.</p>

<p>First, the parser returns both the markdown and HTML as a list of
strings, and each list is reversed. That&rsquo;s why we call
<code>reverse</code> and <code>join</code> on each.</p>

<p>The interesting thing is why we assign the result to module
attributes, <code>@md</code> and <code>@html</code>.</p>

<p>The reason is that <code>test</code> creates a new scope. I needed to be able to
inject both the markdown and the HTML into that scope, but couldn&rsquo;t
use regular variables to do it. However, module attributes have an
interesting property—the value that is used when you reference them is
the value last assigned to them at the point of reference. Each time
around the loop, <code>@md</code> anf <code>@html</code> get new values, and those values
are used when generating the test.</p>

<p>You might complain that this means Elixir has mutable variables, and
you&rsquo;d be right. However, they&rsquo;re only changable at compile time, which
I believe is allowed under standard Mornington Crescent rules.</p>

<p>Finally, the name of the test is simplly the original markdown with a
little decorative line before and after it. This makes our test
failures look something like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'>  <span class="m">3</span><span class="p">)</span> <span class="n">test</span>
</span><span class='line'><span class="o">---</span> <span class="o">===</span> <span class="o">---</span>
</span><span class='line'><span class="err">`</span><span class="n">code</span>
</span><span class='line'><span class="n">span</span><span class="err">`</span>
</span><span class='line'><span class="o">---</span> <span class="o">===</span> <span class="o">---</span>
</span><span class='line'> <span class="p">(</span><span class="no">StmdTest</span><span class="p">)</span>
</span><span class='line'>     <span class="n">test</span><span class="o">/</span><span class="n">stmd_test</span><span class="o">.</span><span class="ss">exs:</span><span class="m">59</span>
</span><span class='line'>     <span class="no">Assertion</span> <span class="n">with</span> <span class="o">==</span> <span class="n">failed</span>
</span><span class='line'>     <span class="ss">code:</span> <span class="n">result</span> <span class="o">==</span> <span class="nv">@html</span>
</span><span class='line'>     <span class="ss">lhs:</span>  <span class="s2">&quot;&lt;p&gt;`code  \nspan`&lt;/p&gt;\n&quot;</span>
</span><span class='line'>     <span class="ss">rhs:</span>  <span class="s2">&quot;&lt;p&gt;&lt;code&gt;code span&lt;/code&gt;&lt;/p&gt;\n&quot;</span>
</span><span class='line'>     <span class="ss">stacktrace:</span>
</span><span class='line'>       <span class="n">test</span><span class="o">/</span><span class="n">stmd_test</span><span class="o">.</span><span class="ss">exs:</span><span class="m">61</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Parsing the spec</h3>

<p><img class="right" src="http://pragdave.me/img/spec-state.png"></p>

<p>Parsing the spec file uses two of my favorite programming tools: state
machines and pattern matching.</p>

<p>The state machine is trivial.</p>

<p>We start scanning the file. When we find a line containing a single
dot, we collect markdown. When we then find a dot, we switch to
collecting HTML. When we find one more dot, we&rsquo;re back to scanning for
the next test.</p>

<p>How do we write a state machine in Elixir? We don&rsquo;t, because Elixir
already comes with the function <code>Enum.reduce</code>. We pass it the
list of lines to process and an accumulator. The accumulator is a
tuple containing the current state and the result. All the state
transitions are then handled by pattern matching. Each pattern
matching function returns a new accumulator—the (potentially updated)
state and result.</p>

<p>Here&rsquo;s the code:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="k">defmodule</span> <span class="no">StmdTest</span><span class="o">.</span><span class="no">Reader</span> <span class="k">do</span>
</span><span class='line'><span class="k">  def</span> <span class="n">tests</span> <span class="k">do</span>
</span><span class='line'><span class="k">    </span><span class="no">File</span><span class="o">.</span><span class="n">open!</span><span class="p">(</span><span class="no">Spec</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
</span><span class='line'>    <span class="o">|&gt;</span> <span class="no">IO</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="ss">:line</span><span class="p">)</span>
</span><span class='line'>    <span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">reduce</span><span class="p">({</span><span class="ss">:scanning</span><span class="p">,</span> <span class="p">[]},</span> <span class="err">&amp;</span><span class="n">split_into_tests</span><span class="o">/</span><span class="m">2</span><span class="p">)</span>
</span><span class='line'>    <span class="o">|&gt;</span> <span class="k">case</span><span class="p">(</span><span class="k">do</span><span class="p">:</span> <span class="p">({</span><span class="ss">:scanning</span><span class="p">,</span> <span class="n">result</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="n">result</span><span class="p">))</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">############</span>
</span><span class='line'>  <span class="c1"># Scanning #</span>
</span><span class='line'>  <span class="c1">############</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">defp</span> <span class="n">split_into_tests</span><span class="p">(</span><span class="s2">&quot;.\n&quot;</span><span class="p">,</span> <span class="p">{</span><span class="ss">:scanning</span><span class="p">,</span> <span class="n">result</span><span class="p">})</span> <span class="k">do</span>
</span><span class='line'><span class="k">    </span><span class="p">{</span> <span class="ss">:collecting_markdown</span><span class="p">,</span> <span class="p">[</span> <span class="err">%</span><span class="p">{</span> <span class="ss">md:</span> <span class="p">[]</span> <span class="p">}</span> <span class="o">|</span> <span class="n">result</span> <span class="p">]</span> <span class="p">}</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">defp</span> <span class="n">split_into_tests</span><span class="p">(</span><span class="n">_other</span><span class="p">,</span> <span class="p">{</span><span class="ss">:scanning</span><span class="p">,</span> <span class="n">result</span><span class="p">})</span> <span class="k">do</span>
</span><span class='line'><span class="k">    </span><span class="p">{</span> <span class="ss">:scanning</span><span class="p">,</span> <span class="n">result</span> <span class="p">}</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">#######################</span>
</span><span class='line'>  <span class="c1"># Collecting Markdown #</span>
</span><span class='line'>  <span class="c1">#######################</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">defp</span> <span class="n">split_into_tests</span><span class="p">(</span><span class="s2">&quot;.\n&quot;</span><span class="p">,</span> <span class="p">{</span><span class="ss">:collecting_markdown</span><span class="p">,</span> <span class="p">[</span> <span class="err">%</span><span class="p">{</span> <span class="ss">md:</span> <span class="n">md</span> <span class="p">}</span> <span class="o">|</span> <span class="n">result</span><span class="p">]})</span> <span class="k">do</span>
</span><span class='line'><span class="k">    </span><span class="p">{</span> <span class="ss">:collecting_html</span><span class="p">,</span> <span class="p">[</span> <span class="err">%</span><span class="p">{</span> <span class="ss">md:</span> <span class="n">md</span><span class="p">,</span> <span class="ss">html:</span> <span class="p">[]</span> <span class="p">}</span> <span class="o">|</span> <span class="n">result</span> <span class="p">]</span> <span class="p">}</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">defp</span> <span class="n">split_into_tests</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="p">{</span><span class="ss">:collecting_markdown</span><span class="p">,</span> <span class="p">[</span> <span class="err">%</span><span class="p">{</span> <span class="ss">md:</span> <span class="n">md</span> <span class="p">}</span> <span class="o">|</span> <span class="n">result</span> <span class="p">]})</span> <span class="k">do</span>
</span><span class='line'><span class="k">    </span><span class="p">{</span> <span class="ss">:collecting_markdown</span><span class="p">,</span> <span class="p">[</span> <span class="err">%</span><span class="p">{</span> <span class="ss">md:</span> <span class="p">[</span><span class="n">line</span><span class="o">|</span><span class="n">md</span><span class="p">]</span> <span class="p">}</span> <span class="o">|</span> <span class="n">result</span> <span class="p">]</span> <span class="p">}</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">###################</span>
</span><span class='line'>  <span class="c1"># Collecting HTML #</span>
</span><span class='line'>  <span class="c1">###################</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">defp</span> <span class="n">split_into_tests</span><span class="p">(</span><span class="s2">&quot;.\n&quot;</span><span class="p">,</span> <span class="p">{</span><span class="ss">:collecting_html</span><span class="p">,</span> <span class="n">result</span><span class="p">})</span> <span class="k">do</span>
</span><span class='line'><span class="k">    </span><span class="p">{</span> <span class="ss">:scanning</span><span class="p">,</span> <span class="n">result</span> <span class="p">}</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">defp</span> <span class="n">split_into_tests</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="p">{</span><span class="ss">:collecting_html</span><span class="p">,</span> <span class="p">[</span> <span class="err">%</span><span class="p">{</span> <span class="ss">md:</span> <span class="n">md</span><span class="p">,</span> <span class="ss">html:</span> <span class="n">html</span><span class="p">}</span> <span class="o">|</span> <span class="n">result</span><span class="p">]})</span> <span class="k">do</span>
</span><span class='line'><span class="k">    </span><span class="p">{</span> <span class="ss">:collecting_html</span><span class="p">,</span> <span class="p">[</span> <span class="err">%</span><span class="p">{</span> <span class="ss">md:</span> <span class="n">md</span><span class="p">,</span> <span class="ss">html:</span> <span class="p">[</span><span class="n">line</span><span class="o">|</span><span class="n">html</span><span class="p">]</span> <span class="p">}</span> <span class="o">|</span> <span class="n">result</span><span class="p">]</span> <span class="p">}</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>There are a couple of things I really like in this code.</p>

<p>First, see how we build the new entry in the result list as we need
it. When we first find a dot in the input, we switch to collecting
markdown, so we add a new map to the result list. That map is
initialized with one key/value pair: <code>md: []</code>. As we collect lines in
the <code>:collecting_markdown</code> state, we add them to the head of that
list.</p>

<p>Similarly, when we detect a dot when collecting markdown, we add an
<code>html: []</code> entry to our result, and move over to start filling it.</p>

<p>The second cool thing is something that makes me love languages such
as Ruby and Elixir.</p>

<p>We normally use <code>case</code> as a control structure:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="k">case</span> <span class="no">File</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;xxx&quot;</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'><span class="p">{</span> <span class="ss">:ok</span><span class="p">,</span> <span class="n">device</span> <span class="p">}</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="n">read</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span> <span class="ss">:error</span><span class="p">,</span> <span class="n">reason</span> <span class="p">}</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="n">complain</span><span class="p">(</span><span class="n">reason</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>But <code>case</code> is really just another function. It takes two parameters:
the value to test against and the keyword list
containing the <code>do</code>&hellip;<code>end</code> block. So it seems like I should be able to
use <code>case</code> in a pipeline—it would receive the pipeline value as its
first parameter.</p>

<p>In this case, I want to do two things. When my state machine
finishes parsing the file, it should be in the <code>:scanning</code> state. If
it isn&rsquo;t, then something went wrong with the parse. Second, the call
to <code>Enum.reduce</code> returns the tuple <code>{ state, test_list }</code>, and I
really just want the list part. I can do both of these by appending
<code>case</code> to my pipeline:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="no">File</span><span class="o">.</span><span class="n">open!</span><span class="p">(</span><span class="no">Spec</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
</span><span class='line'><span class="o">|&gt;</span> <span class="no">IO</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="ss">:line</span><span class="p">)</span>
</span><span class='line'><span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">reduce</span><span class="p">({</span><span class="ss">:scanning</span><span class="p">,</span> <span class="p">[]},</span> <span class="err">&amp;</span><span class="n">split_into_tests</span><span class="o">/</span><span class="m">2</span><span class="p">)</span>
</span><span class='line'><span class="o">|&gt;</span> <span class="k">case</span><span class="p">(</span><span class="k">do</span><span class="p">:</span> <span class="p">({</span><span class="ss">:scanning</span><span class="p">,</span> <span class="n">result</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="n">result</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>If the tuple returned by the <code>reduce</code> call doesn&rsquo;t have a state of
<code>:scanning</code>, I&rsquo;ll get a runtime error (and the error message will show
me what the invalid state was). And, assuming the state is correct,
the body of the <code>case</code> will extract the second element of the tuple
and return it.</p>

<h3>What&rsquo;s the point?</h3>

<p>Is this fantastic code? Of course not. It&rsquo;s a quick hack to get
something I needed working.</p>

<p>But it is <em>enjoyable</em> code. The combination of cool techniques made me
smile, and the unexpected use of <code>case</code> in a pipeline made me really
happy.</p>

<p>And that&rsquo;s why I still code.</p>

<p>(The full source listing is <a href="https://github.com/pragdave/earmark/blob/master/test/stmd_test.exs">on github</a>.)</p>
