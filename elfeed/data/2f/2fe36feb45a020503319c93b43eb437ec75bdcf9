<p>This is the first article of the <a href="/2014/03/12/font-locking-in-emacs.html">Font Locking in Emacs</a> series. It explains the concept of “syntactic fontification” of strings and comments. This font locking technique is the easiest to get started with, although the concept itself is quite intricate and powerful.</p>
<h1 id="syntax-tables">Syntax tables</h1>
<p>Every major mode defines a so-called <a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Tables.html">Syntax Table</a>. A syntax table defines the syntactic role of a <em>single character</em> with various <a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Descriptors.html">Syntax Descriptors</a>. Emacs uses this information for navigation commands and font locking.</p>
<p>When you move over a symbol with <a href="http://doc.endlessparentheses.com/Fun/forward-symbol"><code>forward-symbol</code></a>, it’s the syntax table that tells Emacs where the symbol ends. It’s also the reason, why <a href="http://doc.endlessparentheses.com/Fun/forward-word"><code>forward-word</code></a> stops a dash in Emacs Lisp Mode, whereas <a href="http://doc.endlessparentheses.com/Fun/forward-symbol"><code>forward-symbol</code></a> moves over a dash and stops at the next whitespace or parenthesis: The syntax table of Emacs Lisp mode categorizes the dash as a symbol character, so commands working on words ignore it.</p>
<p>The symbol table also drives the fontification (aka “highlighting”) of strings and comments. Whenever Emacs sees a character which is categorized as string or comment delimiter, subsequent text is fontified as string and comment respectively until a matching delimiter is reached.</p>
<p>The real power of this feature is hidden beneath the phrase “matching delimiter”: If the syntax table is setup properly, Emacs automatically skips across escaped string delimiters inside strings, or across nested comments!</p>
<div class="alert alert-info">
<p><strong>Note!</strong></p>
<p>In this article we’ll only cover the Syntax Table as far as fontification is concerned. Generally, Syntax Tables of major modes are much larger, and also specify word and symbol constituents, paired delimiters, and more, which is important for word, symbol and sexp navigation commands (i.e. the standard <code>forward-*</code> and <code>backward-*</code> family of commands).</p>
<p>When writing the Syntax Table for your own major mode, be sure to consider this as well. At best, read the entire <a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Tables.html">Syntax Table</a> section in the Emacs Lisp reference.</p>
</div>
<h1 id="strings">Strings</h1>
<p>Puppet has two types of strings enclosed in single and double quotes respectively. Let’s define a syntax table that understands these strings:</p>
<div class="highlight"><pre><span class="p">(</span><span class="nb">defvar</span> <span class="nv">puppet-mode-syntax-table</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">table</span> <span class="p">(</span><span class="nv">make-syntax-table</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">modify-syntax-entry</span> <span class="nv">?\&#39;</span> <span class="s">&quot;\&quot;&#39;&quot;</span>  <span class="nv">table</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">modify-syntax-entry</span> <span class="nv">?\&quot;</span> <span class="s">&quot;\&quot;\&quot;&quot;</span> <span class="nv">table</span><span class="p">)</span>
    <span class="nv">table</span><span class="p">)</span>
  <span class="s">&quot;Syntax table in use in `puppet-mode&#39; buffers.&quot;</span><span class="p">)</span>
</pre></div>

<p><a href="http://doc.endlessparentheses.com/Fun/make-syntax-table"><code>make-syntax-table</code></a> creates a standard syntax table, to which we add our custom classifications with <a href="http://doc.endlessparentheses.com/Fun/modify-syntax-entry"><code>modify-syntax-entry</code></a>. This function takes three arguments:</p>
<ol type="1">
<li>The character to classify</li>
<li>The new syntax descriptor for the character</li>
<li>The table to modify</li>
</ol>
<p><a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Descriptors.html">Syntax Descriptors</a> are fairly intricate, but the basic structure is quite simple. A descriptor is a string, where each character has a special meaning. In our example, the descriptors are simple two-character strings.</p>
<p>The first character in this string defines the <strong>syntax class</strong> (see <a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Class-Table.html">Syntax Class Table</a>). The quotation mark <code>&quot;</code> denotes the “String quotes” class, i.e. characters which delimit strings.</p>
<p>The second character denotes the <em>matching character</em>. Unsurprisingly, for our strings the matching character is the same as the character we classify. By specifying the right matching character we make sure that Emacs does not consider a single-quoted to be ended by a double-quote.</p>
<p>Any further characters are <a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Flags.html">Syntax Flags</a>, which we currently don’t need.</p>
<p>This little table is (almost) everything that’s needed for proper fontification of strings! We don’t even need to explicitly enable this table in our major mode, because <a href="http://doc.endlessparentheses.com/Fun/define-derived-mode"><code>define-derived-mode</code></a> (the standard way to declare major modes) already does that for us!</p>
<h1 id="escape-characters">Escape characters</h1>
<p>We’ve just missed a little detail: Emacs doesn’t yet know about the escaping character. As such, it cannot yet detect an escaped string delimiter inside a string. This is easily fixed, however. Just like any other language, Puppet uses the backslash to escape string delimiters, we just need to tell Emacs about this with one extra entry in our syntax table:</p>
<div class="highlight"><pre><span class="p">(</span><span class="nv">modify-syntax-entry</span> <span class="nv">?\\</span> <span class="s">&quot;\\&quot;</span> <span class="nv">table</span><span class="p">)</span>
</pre></div>

<p>This entry puts the backslash into the “Escape characters” class (fittingly denoted by the backslash). Now we are really done: With <strong>just three entries</strong> in our syntax table, Emacs correctly fontifies Puppet’s string syntax!</p>
<h1 id="comments">Comments</h1>
<p>Syntactic fontification also handles comments. Puppet has two types of comments:</p>
<ul>
<li>Shell style comments, starting with a dash <code>#</code> and ending with a new line</li>
<li>C-style comments enclosed in <code>/*</code> and <code>*/</code></li>
</ul>
<p>The first kind is easy:</p>
<div class="highlight"><pre><span class="p">(</span><span class="nv">modify-syntax-entry</span> <span class="nv">?#</span> <span class="s">&quot;&lt;&quot;</span> <span class="nv">table</span><span class="p">)</span>
<span class="p">(</span><span class="nv">modify-syntax-entry</span> <span class="nv">?\n</span> <span class="s">&quot;&gt;&quot;</span> <span class="nv">table</span><span class="p">)</span>
</pre></div>

<p>The first entry puts <code>#</code> into the “Comment Starters” class, i.e. the class of characters which start comments, and the second one the line break into the class of “Comment enders”, i.e. characters which terminate comments.</p>
<p>Now we have line comments, but what about C style comments? These seem to be a little more intricate, since their terminators are two-character sequences. And to make matters even more complicated, <code>/</code> and <code>*</code> have an entirely different meaning when appearing as a single character: They are operators for division and multiplication respectively!</p>
<p>Luckily, Emacs has this common case covered already. Remember the <a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Flags.html">Syntax Flags</a> briefly mentioned in the beginning?</p>
<p>Syntax flags provide additional information about characters, and some of these flags are concerned with two-character syntax. From <a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Flags.html">Syntax Flags</a>:</p>
<ul>
<li>“<code>1</code> means C is the start of a two-character comment-start sequence.</li>
<li><code>2</code> means C is the second character of such a sequence.</li>
<li><code>3</code> means C is the start of a two-character comment-end sequence.</li>
<li><code>4</code> means C is the second character of such a sequence.”</li>
</ul>
<p>With these flags, we can now tune the descriptors of the <code>/</code> and <code>*</code> characters to reflect their comment syntax, as well as their operator meaning::</p>
<div class="highlight"><pre><span class="p">(</span><span class="nv">modify-syntax-entry</span> <span class="nv">?/</span> <span class="s">&quot;. 14&quot;</span> <span class="nv">table</span><span class="p">)</span>
<span class="p">(</span><span class="nv">modify-syntax-entry</span> <span class="nv">?*</span> <span class="s">&quot;. 23&quot;</span> <span class="nv">table</span><span class="p">)</span>
</pre></div>

<p>Both characters are put into the “Punctuation characters” class, which is commonly used for operators. The slot for the matching character is blank, since as operators are naturally no paired characters.</p>
<p>The subsequent flags now specify their comment syntax:</p>
<ul>
<li>With <code>14</code> we tell Emacs that <code>/</code> is the first character of a comment-start sequences and the second character of a comment-end sequences,</li>
<li>and with <code>23</code> we denote that <code>*</code> is goes second in the comment-start and first in the comment-end sequences.</li>
</ul>
<p>This nicely specifies our comment syntax, where <code>/*</code> starts a comment which is then ended by <code>*/</code>. The order of flags doesn’t matter.</p>
<p>When you try this, you’ll notice a serious flaw, though: A comment started <code>/*</code> ends at the next line break! Apparently Emacs doesn’t yet understand, that these are actually two <em>different</em> styles of comments.</p>
<p>We need make Emacs aware of this difference with another flag. From <a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Syntax-Flags.html">Syntax Flags</a>:</p>
<ul>
<li><code>b</code> means that C as a comment delimiter belongs to the alternative “b” comment style. For a two-character comment starter, this flag is only significant on the second char, and for a 2-character comment ender it is only significant on the first char.”</li>
</ul>
<p>By adding this flag, we tell Emacs to consider both comment styles independently, so we replace our first attempt with the following lines:</p>
<div class="highlight"><pre><span class="p">(</span><span class="nv">modify-syntax-entry</span> <span class="nv">?/</span> <span class="s">&quot;. 14b&quot;</span> <span class="nv">table</span><span class="p">)</span>
<span class="p">(</span><span class="nv">modify-syntax-entry</span> <span class="nv">?*</span> <span class="s">&quot;. 23b&quot;</span> <span class="nv">table</span><span class="p">)</span>
</pre></div>

<p>Now we have two independent comment styles for Puppet files.</p>
<h1 id="limits">Limits</h1>
<p>Syntax tables are a powerful tool to fontify strings and comments. We have seen that we can declare different, independent styles of strings and comments, and handle escaping in strings as well as more intricate comment syntax. As such, syntax table can easily cope with comments and strings in many programming languages.</p>
<p>But as always, there are some limitations. With the tiny exception of two-character comment sequences, syntax tables are <strong>stateless</strong>. They only look at the character itself, and do not consider its position in a file or block or its adjacent characters.</p>
<p>As such, whenever the syntactic properties of a character depend on adjacent characters, or on a specific position on a line, syntax tables are out of scope. In such cases, you need to implement fontification in a different way. Let’s briefly look at two common cases.</p>
<p>In many configuration file types the dash starts a comment only when at the beginning of a line or preceded by whitespace only. A common example is <code>.gitignore</code>. Since the syntax of such configuration files is very simple normally, it’s usually sufficient to simply disable syntactic fontification with an appropriate entry in <a href="http://doc.endlessparentheses.com/Var/font-lock-defaults"><code>font-lock-defaults</code></a>, and fontify comments with <a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Search_002dbased-Fontification.html">Search-based fontification</a>, which I’ll cover in the next article of this series.</p>
<p>A more intricate example for the limits of Syntax Tables are strings delimited by multiple characters, such as triple-quoted strings in Python. In such cases its not sufficient to just use Search-based fontification:</p>
<ul>
<li>Such strings usually span many lines, which breaks the line-oriented search pattern of Search-based fontification.</li>
<li>It’s usually important to properly classify the syntax of such strings. Without such a classification, navigation commands such as <a href="http://doc.endlessparentheses.com/Fun/forward-sexp"><code>forward-sexp</code></a> will not be able to recognize and skip strings correctly. Also, many 3rd party extensions such as the popular <a href="https://github.com/Fuco1/smartparens">Smartparens</a> rely on syntactic information. For instance, Smartparens uses syntactic information to make pairs available in specific contexts only.</li>
</ul>
<p>To deal with these issues, Python Mode hooks into the syntactic analysis of Emacs, identifies triple-quoted strings explicitly, and adds special text properties to mark their contents as strings. This is quite a complicated approach, which I’ll probably also cover in a later article in this series.</p>
<h1 id="conclusion">Conclusion</h1>
<p>We’ve seen that Syntactic fontification is a simple, yet powerful approach to fontify the generic syntax of strings and comments, which handle the common variants of string and comments syntax well, but have a very limited ability to deal with stateful syntax.</p>
<p>In the next article of this series, we’ll look at fontifying specific syntactic elements of the Puppet language with <a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Search_002dbased-Fontification.html">Search-based fontification</a>.</p>
<p>Stay tuned!</p>