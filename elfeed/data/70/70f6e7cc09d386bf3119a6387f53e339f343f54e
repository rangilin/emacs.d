<p>The internals of Python are actually pretty straightforward, but it's
still worth a dive. I recently gave a talk at Zillow about it, so I'd
thought I'd share some points here as well.</p>
<p>Everything here prefixed with &gt;&gt;&gt; can be typed into the python
interpreter (activated by typing 'python' in your shell if you have
python installed). I strongly encourage playing and trying some of
this stuff out yourself!</p>
<div class="section" id="basics">
<h2>Basics</h2>
<p>At the core, everything in python is an object. Each object has three properties:</p>
<ul class="simple">
<li>a unique identifier of the object via 'id()'</li>
<li>a type of the object via 'type()'</li>
<li>and it's value</li>
</ul>
<p>The base object is represented by the keyword 'object' in python:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="nb">object</span>
<span class="o">&lt;</span><span class="nb">type</span> <span class="s">&#39;object&#39;</span><span class="o">&gt;</span>
</pre></div>
<p>And you can always find the methods available on any object (i.e. anything) using 'dir':</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="nb">dir</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
<span class="p">[</span><span class="s">&#39;__class__&#39;</span><span class="p">,</span>
 <span class="s">&#39;__delattr__&#39;</span><span class="p">,</span>
 <span class="s">&#39;__doc__&#39;</span><span class="p">,</span>
 <span class="s">&#39;__format__&#39;</span><span class="p">,</span>
 <span class="s">&#39;__getattribute__&#39;</span><span class="p">,</span>
 <span class="s">&#39;__hash__&#39;</span><span class="p">,</span>
 <span class="s">&#39;__init__&#39;</span><span class="p">,</span>
 <span class="s">&#39;__new__&#39;</span><span class="p">,</span>
 <span class="s">&#39;__reduce__&#39;</span><span class="p">,</span>
 <span class="s">&#39;__reduce_ex__&#39;</span><span class="p">,</span>
 <span class="s">&#39;__repr__&#39;</span><span class="p">,</span>
 <span class="s">&#39;__setattr__&#39;</span><span class="p">,</span>
 <span class="s">&#39;__sizeof__&#39;</span><span class="p">,</span>
 <span class="s">&#39;__str__&#39;</span><span class="p">,</span>
 <span class="s">&#39;__subclasshook__&#39;</span><span class="p">]</span>
</pre></div>
<p>So let's talk a little bit about the more interesting ones:</p>
<ul class="simple">
<li>__class__ returns the type of an object. If the object is a type, it returns the type 'type'</li>
<li>__doc__ is the docstring attached to a file. These are the triple quotes contained directly below a method or class declaration.</li>
<li>__new__ is called whenever a new instance of an object is created. It almost always calls __init__</li>
<li>__sizeof__ get the size of the object. One can also use sys.getsizeof. This isn't the most reliable because it doesn't get the size of referenced objects, just the size of the reference itself.</li>
<li>__delattr__, __getattribute__, and __setattr__ are used to get the attributes regarding a particular object. However, you should use (set|get|has)attr methods instead of directly calling these.</li>
</ul>
</div>
<div class="section" id="types">
<h2>Types</h2>
<p>Types are special kind of object in Python, designed to be
constructors for classes. It's not possible to create a new object
(aside from built-in shorthand like {} for dictionaries and [] for
lists) without using a type object and instantiating something with it:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="nb">object</span><span class="p">()</span>
<span class="o">&lt;</span><span class="nb">object</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x7f1e14eee080</span><span class="o">&gt;</span>
</pre></div>
</div>
<div class="section" id="exec-eval-and-compile">
<h2>exec, eval, and compile</h2>
<p>exec, eval, and compile are also built-in functions in Python. They
compile and evaluate code.</p>
<p>'exec' executes a particlular string of code</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="k">exec</span><span class="p">(</span><span class="s">&quot;print &#39;hello world&#39;&quot;</span><span class="p">)</span>
<span class="n">hello</span> <span class="n">world</span>
</pre></div>
<p>'eval' evaluates an expression. <em>Note</em>: this can not be a statement. e.g. assigning a value.</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="nb">eval</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">)</span>
<span class="mi">1</span>
</pre></div>
<p>'compile' compiles an expression or statement into a 'code' objects,
which actually contained the byte-compiled executable code, and is
what gets ultimately executed by Python.</p>
<p>Note that you have to choose to either 'eval' or 'exec' the string
passed.  Conversely, you can pass a file.</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="nb">compile</span><span class="p">(</span><span class="s">&#39;./test.py&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">compile</span><span class="p">(</span><span class="s">&#39;print &quot;hello world&quot;, &#39;&#39;, &#39;</span><span class="k">exec</span><span class="s">&#39;)</span>
</pre></div>
</div>
<div class="section" id="functions">
<h2>Functions</h2>
<p>Functions (or methods) consist of two objects:</p>
<ul class="simple">
<li>a code object, containing the bytecode for a particular object</li>
<li>a globals dictionary, containing the global variables necessary</li>
</ul>
<p>One can't instantiate functions directly, so we have to get the type of a function first:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">ftype</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">None</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fn</span> <span class="o">=</span> <span class="n">ftype</span><span class="p">(</span><span class="nb">compile</span><span class="p">(</span><span class="s">&#39;print test&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="s">&#39;exec&#39;</span><span class="p">),</span> <span class="p">{</span><span class="s">&#39;test&#39;</span><span class="p">:</span> <span class="s">&quot;hello world&quot;</span><span class="p">})</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fn</span>
<span class="o">&lt;</span><span class="n">function</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fn</span><span class="p">()</span>
<span class="n">hello</span> <span class="n">world</span>
</pre></div>
<p>So what's actually going on here?</p>
<ul class="simple">
<li>I get the type object of function. The easiest method to do this is
to get the type of a lambda method which returns None. Since the
type of the lambda is a 'function', it's the quickest way to get
what we need.</li>
</ul>
<p>If you wanted to modify a function directly, you can! There's a large
number of method available that you can play with.</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;func&#39;</span><span class="p">),</span> <span class="nb">dir</span><span class="p">(</span><span class="n">fn</span><span class="p">))</span>
<span class="p">[</span><span class="s">&#39;func_closure&#39;</span><span class="p">,</span>
 <span class="s">&#39;func_code&#39;</span><span class="p">,</span>
 <span class="s">&#39;func_defaults&#39;</span><span class="p">,</span>
 <span class="s">&#39;func_dict&#39;</span><span class="p">,</span>
 <span class="s">&#39;func_doc&#39;</span><span class="p">,</span>
 <span class="s">&#39;func_globals&#39;</span><span class="p">,</span>
 <span class="s">&#39;func_name&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fn</span><span class="o">.</span><span class="n">func_name</span>
<span class="s">&#39;&lt;module&gt;&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fn</span><span class="o">.</span><span class="n">func_name</span> <span class="o">=</span> <span class="s">&#39;hello_world&#39;</span>
<span class="s">&#39;hello_world&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fn</span><span class="o">.</span><span class="n">func_code</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="s">&#39;print &quot;not &quot; + test&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="s">&#39;exec&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fn</span><span class="p">()</span>
<span class="ow">not</span> <span class="n">hello</span> <span class="n">world</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fn</span><span class="o">.</span><span class="n">func_globals</span><span class="p">[</span><span class="s">&#39;test&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;goodbye world&quot;</span>
<span class="ow">not</span> <span class="n">goodbye</span> <span class="n">world</span>
</pre></div>
</div>
<div class="section" id="classes">
<h2>Classes</h2>
<p>Classes are just basically custom types. How can you tell? It's made by using the 'type' constructor!</p>
<p>The 'type' method can not only return the type of an object, it can
create one for you too! Since 'type' is a type object, it can be used
to instantiate new types.</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s">&#39;MyClassType&#39;</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{</span><span class="s">&#39;test&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="mi">1</span> <span class="p">})</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">test</span>
<span class="o">&lt;</span><span class="n">bound</span> <span class="n">method</span> <span class="n">MyClassType</span><span class="o">.&lt;</span><span class="k">lambda</span><span class="o">&gt;</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">MyClassType</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x7f524b71e510</span><span class="o">&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">test</span><span class="p">()</span>
<span class="mi">1</span>
</pre></div>
<p>The syntax is:</p>
<div class="highlight"><pre><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">attributes</span> <span class="o">+</span> <span class="n">values</span><span class="p">)</span>
</pre></div>
<ul class="simple">
<li>Name: the name of the new type</li>
<li>Parents: references to the parent classes</li>
<li>attributes + values: a list of tuples of the key and values of the attributes of the class.</li>
</ul>
<p>Python's objects are incredibly maleable. You can actually modify class methods directly:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">test</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span> <span class="p">:</span> <span class="k">return</span> <span class="s">&quot;noooo!&quot;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">test</span><span class="p">()</span>
<span class="n">noooo</span><span class="err">!</span>
</pre></div>
<p>Although you can also override the method on the instance directly:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">test</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span> <span class="p">:</span> <span class="k">return</span> <span class="s">&quot;yes!&quot;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">test</span><span class="p">()</span>
<span class="n">yes</span><span class="err">!</span>
</pre></div>
<p>So how does this work? Well every python object who's type isn't a
built in (think str, int) contains a dictionary-like object with all
of it's attributes. This can be viewed by the &quot;__dict__&quot; attribute of an object:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">ABC</span><span class="p">:</span>
<span class="o">...</span>     <span class="k">pass</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">ABC</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">a</span>
<span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">ABC</span> <span class="n">instance</span> <span class="n">at</span> <span class="mh">0x19879e0</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">__dict__</span>
<span class="p">{}</span>
</pre></div>
<p>So how does Python know which attribute to call? This is actually
dictated in a method! If you noticed, when I ran a dir() on the
object, there was an attribute '__getattribute__'. This method
defaults to:</p>
<ul class="simple">
<li>if the attribute is in the object's own __dict__, then use that method.</li>
<li>if not, the attribute call's it's parents __getattribute__ method,
which of course recurses to it's own parents on being unable to find it</li>
</ul>
<p>One of the things about __dict__ is it's not directly writable. If you
want to modify attributes on an object, python provides built-in
functions for this:</p>
<ul class="simple">
<li>hasattr(foo, 'bar') returns true if the object foo has the attribute 'bar'</li>
<li>getattr(foo, 'bar') returns the attribute foo.bar</li>
<li>setattr(foo, 'bar', val) is equivalent to foo.bar = val</li>
</ul>
<p>back to classes/types, there's some interesting hidden features as well:</p>
<p>You can find out all the superclasses of a 'type' with .__bases__:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">__bases__</span>
<span class="p">(</span><span class="nb">object</span><span class="p">,)</span>
</pre></div>
<p>And all subclasses:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="nb">str</span><span class="o">.</span><span class="n">__subclasses__</span><span class="p">()</span>
<span class="p">[</span><span class="o">&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">apt</span><span class="o">.</span><span class="n">package</span><span class="o">.</span><span class="n">__dstr</span><span class="s">&#39;&gt;]</span>
</pre></div>
<p>So how could I find all the classes in my scope? Since everything is
an object, we just find all subclasses of it.</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="nb">object</span><span class="o">.</span><span class="n">__subclasses__</span><span class="p">()</span>
</pre></div>
<p>Pop Quiz: Is object a subclass of type, or visa versa?</p>
<p>Answer: both are subclasses of each other! Kind of.</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="nb">object</span><span class="p">)</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
<span class="bp">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="nb">object</span><span class="p">)</span>
<span class="bp">True</span>
</pre></div>
</div>
<div class="section" id="frames">
<h2>Frames</h2>
<p>Want to look at the stack frames within python? That's possible too.</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">sys</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span>
</pre></div>
<p>Will get you an instance of the existing frame, with references to the variables in the inner scope, outer scope, and more!</p>
</div>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>There's a lot of interesting stuff going on under the hood of Python,
way beyond the brief discussion I covered here. The interpretive
nature of python is one that promotes exploration, so don't hesitate!
Explore the wonderful world of python internals.</p>
</div>
