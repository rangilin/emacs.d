
<div xmlns="http://www.w3.org/1999/xhtml"><p>Every once in a while I get irritated by the edges in programming languages.&nbsp; One notorious edge is the absence or presence of a method on an object.&nbsp; The method is either there or it isn't and if you guess wrong you have a program that simply doesn't run. &nbsp;</p>
<p>In some programming languages, there is a way around this.&nbsp; You can hook into the runtime to generate a method on an object when it is called but doesn't yet exist.&nbsp; Of course, that leaves us with the decision of what method to generate. And, I suspect that some of you reading this are wondering now whether this is some sort of rabbit hole - what problem am I trying to solve?&nbsp; In most cases, the fact that a method doesn't exist is important. We shouldn't gloss over it. But, sometimes we can gain advantage when we do.</p>
<p>Consider finder methods. You have some criterion you want to use to find an object. Maybe some unique id.&nbsp; You call your finder and you have to deal with possibility that the thing you are looking for doesn't exist.&nbsp; Most of the time this means that you are obligated to use a null check in your language, but that's messy and people can easily forget to do it. Some functional programming languages get around this by using a Maybe or Option type, but there's another way to punt.&nbsp; You can make your finder always return a collection. If the thing you are looking for is not found, you receive an empty collection. "Okay," I can hear you say, "that is just passing the buck. You have to check later."&nbsp; The fact of the matter is that you may not have to. You could use a map to perform the same operation on each of the elements, provided there is no chance of having more than one.</p>
<pre><code>    finder(criterion).map(&amp;:run)</code></pre>
<p>This makes me wonder about something.&nbsp; What if we were were able to treat values as collections when we are programming?</p>
<p>Consider this in a dynamic language.</p>
<pre><code>    x = 4</pre></code>
<p>When we type that, we expect that <code>x[0]</code> will yield an error, and we expect that <code>x[1][59][3]</code> would yield an error also.&nbsp; But what if they didn't?&nbsp; What if each of those references returned <code>4</code>. What if values could be treated as infinite collections of themselves in programming?&nbsp; Could that be a creative way of erasing an edge?&nbsp;</p>
<p>Consider this in a Haskell-ish language.</p>
<pre><code>    map (+1) [1,2,3]</pre></code>
<p>We know that would yield <code>[2,3,4]</code></p>
<p>Okay, how about this?</p>
<pre><code>    map (+1) 3</pre></code>
<p>Couldn't that evaluate to <code>4</code>?</p>
<p>With an operation like <i>map</i>, this is easy.&nbsp; What about <i>fold</i> (codenamed <i>reduce</i> or <i>inject</i> in some languages)?</p>
<p>If we did something like: <code>[0,1,2].reduce(:+)</code> in Ruby, we'd expect the sum.</p>
<p>What should we expect for this?
<pre><code>    2.reduce(:+)</pre></code>
<p>The sensible answer is: <code>2</code>. A case could be made for infinity as it is the sum of an infinite list of 2s, but I think we can just say that it evaluates to <code>2</code> and maintain consistency.</p>
<p>Maybe there is an inconsistency in this and it all falls down. But I hope that it works and that there is an efficient way to merge scalar values and collections of the same value. I suspect I'm just reinventing APL in conventional programming languages.</p>
<p>&nbsp;</p></div>
