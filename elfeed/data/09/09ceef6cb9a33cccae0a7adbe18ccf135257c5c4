<p><em>Disclosure: This blog post is part of the Panamax Template Contest.</em></p>
<p>In my blog post about the <a href="http://blog.printf.net/articles/2014/02/10/dell-c6100-xs23-sb-server/">Dell C6100 server</a> I’ve been using, I mentioned that I run a full LXC userland for each application I deploy, and that I’d like to try out <a href="https://www.docker.com/">Docker</a> but that this setup is in conflict with Docker’s philosophy – a Docker container only runs one process, which makes it difficult to use Docker for anything requiring interaction between processes. Here’s an example: this blog is running WordPress with MySQL. So, with LXC I create a fresh Ubuntu container for the blog and run <code>apt-get install wordpress</code> and I’m up and running, but trying to use Docker would leave me with an “orchestration” problem – if I’m supposed to have a separate web server and database server, how will they figure out how to talk to each other?</p>
<p>If the two Docker services are being run on the same host, you can use <code>docker --link</code>, which runs one service under a given name and then makes it available to any service it’s linked to. For example, I could call a postgres container <code>db</code> and then run something like <code>docker --name web --link db:db wordpress</code>. The wordpress container receives environment variables giving connection information for the database host, which means that as long as you can modify your application to use environment variables when deciding which database host to connect to, you’re all set. (If the two docker services are being run on <em>separate</em> hosts, you have an “ambassador” problem to figure out.)</p>
<p>All of which is a long-winded way to say that <a href="http://panamax.io/">Panamax</a> is a new piece of open source software that attempts to ameliorate the pain of solving orchestration problems like this one, and I decided to try it out. It’s a web service that you run locally, and it promises a drag-and-drop interface for building out complex multi-tier Docker apps. Here’s what it looks like when pairing a postgres database with a web server running a Django app, WagtailCMS:</p>
<div align="left"><img alt="" src="http://chris.printf.net/panamax.png" /></div>
<p>The technical setup of Panamax is interesting. It’s distributed as a CoreOS image which you run inside Vagrant and Virtualbox, and then your containers are launched from the CoreOS image. This means that Panamax has no system dependencies other than Vagrant and Virtualbox, so it’s easily usable on Windows, OS X, or any other environment that can’t run Docker directly.</p>
<p>Looking through the templates already created, I noticed an example of combining Rails and Postgres. I like Django, so I decided to give Django and Postgres a try. I found mbentley’s <a href="https://registry.hub.docker.com/u/mbentley/ubuntu-django-uwsgi-nginx/">Ubuntu + nginx + uwsgi + Django</a> docker image on the Docker Hub. Comparing it to the Rails and Postgres template on Panamax, the Django container lacks database support, but does have support for overlaying your own app into the container, which means you can do live-editing of your app.</p>
<p>I decided to see if I could combine the best parts of both templates to come up with a Panamax template for hosting arbitrary Django apps, which supports using an external database and offers live-editing.  I ended up creating a new Docker image, with the unwieldy name of <a href="https://registry.hub.docker.com/u/cjbprime/ubuntu-django-uwsgi-nginx-live/">cjbprime/ubuntu-django-uwsgi-nginx-live</a>.  This image is based on mbentley’s, but supports having a Django app passed in as an image, and will try to install its requirements.  You can also link this image to a database server, and syncdb/migrate will be run when the image starts to set things up.  If you need to create an admin user, you can do that inside a <code>docker_run.sh</code> file in your app directory.</p>
<p>After combining this new Docker image with a Postgres container, I’m very happy with how my <a href="https://github.com/CenturyLinkLabs/panamax-contest-templates/blob/master/django_with_postgres.pmx">django-with-postgres</a> template turned out – I’m able to take an existing Django app, make minor changes using a text editor on my local machine to use environment variables for the database connection, start up the Panamax template, and watch as a database is created (if necessary), dependencies are installed, migrations are run, an admin user is created (if necessary), and the app is launched.  All without using a terminal window at any point in the process.</p>
<p>To show a concrete example, I also made a template that bundles the <a href="http://wagtail.io/">Wagtail Django CMS</a> demo. It’s equivalent to just using my <code>django-with-postgres</code> container with the wagtaildemo code passed through to the live-editing overlay image (in <code>/opt/django/app</code>), and it brings up wagtaildemo with a postgres DB in a separate container. Here’s what that looks like:</p>
<div align="left"><img alt="" src="http://chris.printf.net/wagtail.png" /></div>
<p>Now that I’ve explained where I ended up, I should talk about how Panamax helped.  Panamax introduced me to Docker concepts (linking between containers, overlaying images) that I hadn’t used before because they seemed too painful, and helped me create something cool that I wouldn’t otherwise have attempted.  There were some frustrations, though.  First, the small stuff:</p>
<h4>Underscores in container names</h4>
<p>This one should have been in big bold letters at the top of the release notes, I think.  Check this out: <a href="https://github.com/coreos/go-systemd/pull/49">unit names with _{a-f}{a-f} in them cause dbus to crash</a>. This is amusing in retrospect, but was pretty inscrutable to debug, and perhaps made worse by the Panamax design: there’s a separate frontend web service and backend API, and when the backend API throws an error, it seems that the web interface doesn’t have access to any more detail on what went wrong. I’m lucky that someone on IRC volunteered the solution straight away.</p>
<h4>The CoreOS Journal box occasionally stays black</h4>
<p>Doing Docker development depends heavily on being able to see the logs of the running containers to work out why they aren’t coming up as you thought they would.  In Docker-land this is achieved with <code>docker -f logs &lt;cid&gt;</code>, but Panamax brings the logs in to the web interface: remember, the goal is to avoid having to look at the terminal at all.  But it doesn’t work sometimes.  There’s a <code>panamax ssh</code> command to ssh into the CoreOS host and run <code>docker logs</code> there, but that’s breaking the “fourth wall” of Panamax.</p>
<h4>Progress bar when pulling Docker images</h4>
<p>A minor change: it’d be great to be able to see progress when Panamax is pulling down a Docker image.  There’s no indicator of progress, which made me think that something had hung or failed.  Further, systemd complained about the app failing to start, when it just needed more time for the <code>docker pull</code> to complete.</p>
<h4>Out of memory when starting a container</h4>
<p>The CoreOS host allocates 1GB RAM for itself: that’s for the Panamax webapp (written in Rails), its API backend, and any containers you write and launch.  I had to increase this to 2GB while developing, by modifying <code>~/.panamax/.env</code>:</p>
<pre>export PMX_VM_MEMORY=2048</pre>
<h4>Sharing images between the local host and the container</h4>
<p>I mentioned how Panamax uses a CoreOS host to run everything from, and how this drastically reduces the install dependencies.  There’s a significant downside to this design – I want to allow my local machine to share a filesystem and networking with my Docker container, but now there’s a CoreOS virtual machine in the way – I can’t directly connect from my laptop to the container running Django without hopping through the VM somehow. I want to connect to it for two different reasons:</p>
<ol>
<li>To have a direct TCP connection from my laptop to the database server, so that I can make database changes if necessary.</li>
<li>To share a filesystem with a container so that I can test my changes live.</li>
</ol>
<p>Panamax makes the first type of connection reasonably easy. There’s a VirtualBox command for doing port forwarding from the host through to the guest – the guest in this case is the CoreOS host. So we end up doing two stages of port forwarding: Docker forwards port 80 from the Django app out to port 8123 on the CoreOS host, and then VirtualBox forwards port 8123 on my laptop to port 8123 on the CoreOS host. Here’s the command to make it work:</p>
<pre>VBoxManage controlvm panamax-vm natpf1 rule1,tcp,,8123,,8123</pre>
<p>The filesystem sharing is much trickier – we need to share a consistent view of a single directory between <em>three</em> hosts: again, the laptop, the CoreOS host, and the Docker app. Vagrant has a solution to this, which is that it can NFS share a guest OS from the CoreOS host back to my laptop. That works like this, modifying <code>~/.vagrant.d/boxes/panamax-coreos-box-367/0/virtualbox/Vagrantfile</code>:</p>
<pre>  config.vm.network "private_network", ip: "192.168.50.4"
  config.vm.synced_folder "/home/cjb/djangoapp", "/home/core/django",
  id: "django", :nfs =&gt; true, :mount_options =&gt; ['nolock,vers=3,udp']</pre>
<p>So, we tell Panamax to share <code>/opt/django/app</code> with the CoreOS host as <code>/home/core/django</code>, and then we tell Vagrant to share <code>/home/cjb/djangoapp</code>on my laptop with the CoreOS host as <code>/home/core/django</code> over NFS.  After `apt-get install nfs-kernel-server`, trying this leads to a weird error:</p>
<pre>exportfs: /home/cjb/djangoapp does not support NFS export</pre>
<p>This turns out to be because I’m running ecryptfs for filesystem encryption on my Ubuntu laptop, and nfs-kernel-server can’t export the encrypted FS. To work around it, I mounted a tmpfs for my Django app and used that instead. As far as I know, OS X and Windows don’t have this problem.</p>
<h4>Summary</h4>
<p>Panamax taught me a lot about Docker, and caused me to publish my first two images to the Docker registry, which is more than I expected to gain from trying it out.  I’m not sure I’m the target audience – I don’t think I’d want to run production Docker apps under it on a headless server (at least until it’s more stable), which suggests that its main use is as an easy way to experiment with the development of containerized systems.  But the friction introduced by the extra CoreOS host seems too great for it to be an awesome development platform for me.  I think it’s a solvable problem – if the team can find a way to make the network port forwarding and the filesystem NFS sharing be automatic, rather than manual, and to work with ecryptfs on Ubuntu, it would make a massive difference.</p>
<p>I am impressed with the newfound ability to help someone launch a database-backed Django app without using any terminal commands, even if they’re on Windows and have no kind of dev environment, and would consider recommending Panamax for someone in that situation.  Ultimately, maybe what I’ll get out of Panamax is a demystification of Docker’s orchestration concepts.  That’s still a pretty useful experience to have.</p>