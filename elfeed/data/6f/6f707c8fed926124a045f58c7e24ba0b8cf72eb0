<p>
Yesterday I had a problem that <code>core.async</code> provides an incredibly neat
solution to. Tim Baldridge was kind enough to sanity check it for me,
so I thought I'd write it up.
</p>

<p>
Imagine you want to process a message at a maximum rate of one per
second. In another language you'd probably say something like:
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #66D9EF;">while</span> true:
        <span style="color: #F92672;">start_time</span> = date()
        process_message(queue)
        <span style="color: #F92672;">end_time</span> = date()

        <span style="color: #F92672;">elapsed_time</span> = end_time.subtract(start_time)

        <span style="color: #66D9EF;">if</span> elapsed_time &lt; 1000
                sleep(1000 - elapsed_time)
</pre>
</div>

<p>
Not hard to write, of course, but kinda clumsy. Here's the <code>core.async</code>
version:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #A6E22E;">while</span> true
  (<span style="color: #66D9EF;">let</span> [t (<span style="color: #A6E22E;">timeout</span> 1000)]
    (process-message queue)
    (<span style="color: #A6E22E;">&lt;!!</span> t)))
</pre>
</div>

<p>
In English, pick up a ticket that lasts for 1000 milliseconds; process
a message; wait until the ticket expires.  If processing the message
took more than 1000ms, the ticket returns immediately, otherwise it
blocks for the remaining time.
</p>

<p>
Simple <i>and</i> easy. A really neat solution.
</p><img src="http://feeds.feedburner.com/~r/KrisJenkinsBlog/~4/PcW2EfTTcmQ" height="1" width="1"/>