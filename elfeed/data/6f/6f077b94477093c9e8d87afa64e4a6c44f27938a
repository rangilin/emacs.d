<h1 id="background">Background</h1>
<p>In this blog I’m using <a href="http://johnmacfarlane.net/pandoc/">Pandoc</a> to convert Markdown to HTML. It’s by far the best and most powerful markdown converter, but it has one, albeit little weakness: Its syntax highlighting is based <a href="http://hackage.haskell.org/package/highlighting-kate">highlighting-kate</a>, which is less good and supports less languages than the Python library <a href="http://pygments.org/">Pygments</a>, the de-facto standard highlighter used by Github and others.</p>
<p>Fortunately, it’s easy to implement custom highlighting thanks to the great API of Pandoc, with just two functions in <a href="https://github.com/lunaryorn/blog/blob/f9c1c518bb140d25a49ca2592d8664a43c67ff6f/src/Text/Highlighting/Pygments/Pandoc.hs"><strong>Text.Highlighting.Pygments.Pandoc</strong></a>:</p>
<div class="highlight"><pre><span class="kr">import</span> <span class="nn">Text.Highlighting.Pygments</span> <span class="p">(</span><span class="nf">toHtml</span><span class="p">)</span>

<span class="nf">blockToHtml</span> <span class="ow">::</span> <span class="kt">Block</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">Block</span>
<span class="nf">blockToHtml</span> <span class="n">x</span><span class="o">@</span><span class="p">(</span><span class="kt">CodeBlock</span> <span class="n">attr</span> <span class="kr">_</span><span class="p">)</span> <span class="o">|</span> <span class="n">attr</span> <span class="o">==</span> <span class="n">nullAttr</span> <span class="ow">=</span> <span class="n">return</span> <span class="n">x</span>
<span class="nf">blockToHtml</span> <span class="n">x</span><span class="o">@</span><span class="p">(</span><span class="kt">CodeBlock</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span><span class="kt">[]</span><span class="p">,</span><span class="kr">_</span><span class="p">)</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">return</span> <span class="n">x</span>
<span class="nf">blockToHtml</span> <span class="p">(</span><span class="kt">CodeBlock</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span><span class="n">language</span><span class="kt">:</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">)</span> <span class="n">text</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">colored</span> <span class="ow">&lt;-</span> <span class="n">toHtml</span> <span class="n">text</span> <span class="n">language</span>
  <span class="n">return</span> <span class="p">(</span><span class="kt">RawBlock</span> <span class="p">(</span><span class="kt">Format</span> <span class="s">&quot;html&quot;</span><span class="p">)</span> <span class="n">colored</span><span class="p">)</span>
<span class="nf">blockToHtml</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">return</span> <span class="n">x</span>

<span class="nf">codeBlocksToHtml</span> <span class="ow">::</span> <span class="kt">Pandoc</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">Pandoc</span>
<span class="nf">codeBlocksToHtml</span> <span class="ow">=</span> <span class="n">walkM</span> <span class="n">blockToHtml</span>
</pre></div>

<p>This code transforms all code blocks to a raw HTML block containing the code highlighted by Pygments. The language used in the code block is taken from the first unnamed attribute of the code block, just like in Github’s markdown dialect. Code blocks which do not specify a language are not touched.</p>
<p>So far I just went the easy way, and called the <a href="http://pygments.org/docs/cmdline/"><code>pygmentize</code> script</a> in <code>toHtml</code>, passing the code to be highlighted on stdin, and reading the result from stdout. While this is easy to implement with just a few lines, it’s also very, very slow.</p>
<p>Last weekend I sat down and tried to call Pygments directly via Python’s C API through Haskell’s FFI. This is what came out of this attempt.</p>
<h1 id="native-wrappers">Native wrappers</h1>
<p><a href="https://github.com/lunaryorn/blog/blob/e0d3faa6d95cb567d7356dec902575691051b5a5/src/Foreign/Python/Native.hsc"><strong>Foreign.Python.Native</strong></a> is an <a href="http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/hsc2hs.html">hsc2hs</a> module which imports the required functions from Python’s C API and declares corresponding Haskell signatures.</p>
<p>The module also declares the necessary types, using a special <code>hsc2hs</code> feature to automatically derive the right Haskell type for a given C type. For instance, the following declaration declares an appropriate Haskell alias for Python’s <code>Py_ssize_t</code>, so I didn’t need to grok the header files for the typedef:</p>
<div class="highlight"><pre><span class="kr">type</span> <span class="kt">PySSizeT</span> <span class="ow">=</span> <span class="o">#</span><span class="kr">type</span> <span class="kt">Py_ssize_t</span>
</pre></div>

<p>I also use the <code>CApiFFI</code> extension to avoid the hassle of finding out whether to import the UCS2 or the UCS4 API of CPython. Instead, I just import the macro API and let GHC figure out the rest:</p>
<div class="highlight"><pre><span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">capi</span> <span class="n">unsafe</span> <span class="s">&quot;Python.h PyUnicode_AsUTF8String&quot;</span>
  <span class="n">pyUnicode_AsUTF8String</span> <span class="ow">::</span> <span class="kt">RawPyObject</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">RawPyObject</span>

<span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">capi</span> <span class="n">unsafe</span> <span class="s">&quot;Python.h PyUnicode_FromStringAndSize&quot;</span>
  <span class="n">pyUnicode_FromStringAndSize</span> <span class="ow">::</span> <span class="kt">CString</span> <span class="ow">-&gt;</span> <span class="kt">PySSizeT</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">RawPyObject</span>
</pre></div>

<p>GHC automatically generates a wrapper C functions for these macros, and figures out whether to link <code>PyUnicodeUCS2_AsUTF8String</code> or <code>PyUnicodeUCS4_AsUTF8String</code>.</p>
<h1 id="convenient-haskell-api">Convenient Haskell API</h1>
<p><a href="https://github.com/lunaryorn/blog/blob/e0d3faa6d95cb567d7356dec902575691051b5a5/src/Foreign/Python.hs"><strong>Foreign.Python</strong></a> is the convenient Haskell API around the <a href="#native-wrappers">native Python functions</a>.</p>
<div class="alert alert-info">
<p><strong>Update!</strong> <small> Apr 16, 2014</small></p>
<p>I changed <code>toPyObject</code> to return <code>Nothing</code> if given a null pointer, for increased safety. Previously <code>toPyObject</code> would simply wrap the given pointer, whether <code>NULL</code> or not.</p>
<p>While wrapping a <code>NULL</code> pointer in a managed pointer doesn’t do any harm in and by itself, because the dereferencing functions from Python are safe to call with <code>NULL</code>, it was still possible to try and use the pointer, e.g. by trying to call the underlying Python object, and thus trigger a segfault.</p>
<p>Now it’s impossible to obtain a <code>PyObject</code> from <code>NULL</code>, increasing the safety of my Python API.</p>
<p>The definition of <code>toPyObjectChecked</code> was updated accordingly.</p>
</div>
<p>I use <code>ForeignPtr</code> to wrap the raw <code>PyObject</code> pointers into an opaque Haskell type which automatically calls <code>Py_XDECREF</code> on the underlying <code>PyObject</code> when it goes out of scope:</p>
<div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">PyObject</span> <span class="ow">=</span> <span class="kt">PyObject</span> <span class="p">(</span><span class="kt">ForeignPtr</span> <span class="nb">()</span><span class="p">)</span>

<span class="nf">toPyObject</span> <span class="ow">::</span> <span class="kt">RawPyObject</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">PyObject</span><span class="p">)</span>
<span class="nf">toPyObject</span> <span class="n">raw</span> <span class="o">|</span> <span class="n">raw</span> <span class="o">==</span> <span class="n">nullPtr</span>  <span class="ow">=</span> <span class="n">return</span> <span class="kt">Nothing</span>
<span class="nf">toPyObject</span> <span class="n">raw</span> <span class="ow">=</span> <span class="n">liftM</span> <span class="p">(</span><span class="kt">Just</span> <span class="o">.</span> <span class="kt">PyObject</span><span class="p">)</span> <span class="p">(</span><span class="n">newForeignPtr</span> <span class="n">pyDecRef</span> <span class="n">raw</span><span class="p">)</span>

<span class="nf">withPyObject</span> <span class="ow">::</span> <span class="kt">PyObject</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">RawPyObject</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
<span class="nf">withPyObject</span> <span class="p">(</span><span class="kt">PyObject</span> <span class="n">ptr</span><span class="p">)</span> <span class="ow">=</span> <span class="n">withForeignPtr</span> <span class="n">ptr</span>
</pre></div>

<p>Only the opaque type is exported from the module, so outside code never has any chance of messing with the underlying C object and bypassing the garbage collector.</p>
<p>Many CPython functions return <code>NULL</code> to indicate that the operation failed and a Python exception was raised. To deal with these situations I use a little helper that throws a Haskell exception from the current Python exception if given a <code>NULL</code> pointer:</p>
<div class="highlight"><pre><span class="nf">toPyObjectChecked</span> <span class="ow">::</span> <span class="kt">RawPyObject</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">PyObject</span>
<span class="nf">toPyObjectChecked</span> <span class="ow">=</span> <span class="n">toPyObject</span> <span class="o">&gt;=&gt;</span> <span class="n">maybe</span> <span class="n">throwCurrentPythonException</span> <span class="n">return</span>
</pre></div>

<p>To obtain objects from the Python runtime, I define a bunch of functions to import modules, get attributes and call objects. The implementations are mostly boilerplate code, so I’ll just show you the type signatures:</p>
<div class="highlight"><pre><span class="nf">importModule</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">PyObject</span>
<span class="nf">getAttr</span>      <span class="ow">::</span> <span class="kt">PyObject</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">PyObject</span>
<span class="nf">callObject</span>   <span class="ow">::</span> <span class="kt">PyObject</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">PyObject</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="kt">PyObject</span><span class="p">,</span> <span class="kt">PyObject</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">PyObject</span>
</pre></div>

<p>To convert these objects from Haskell, and to pass Haskell objects to Python, I use a little type class to convert a type to and from Python:</p>
<div class="highlight"><pre><span class="kr">class</span> <span class="kt">Object</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">toPy</span>   <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">PyObject</span>
  <span class="n">fromPy</span> <span class="ow">::</span> <span class="kt">PyObject</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
</pre></div>

<p>As I only need strings to call Pygments, there are only two instances for <code>ByteString</code> and <code>String</code>.</p>
<p>To convert from a <code>ByteString</code>, I just need to obtain a temporary buffer from the byte string and pass that to Python:</p>
<div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Object</span> <span class="kt">ByteString</span> <span class="kr">where</span>
  <span class="n">toPy</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">useAsCStringLen</span> <span class="n">s</span> <span class="o">$</span> <span class="nf">\</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="ow">-&gt;</span>
    <span class="n">pyString_FromStringAndSize</span> <span class="n">buffer</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="n">len</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">toPyObjectChecked</span>
</pre></div>

<p>Converting back to a is a little more intricate, because Python needs addressable fields to take the raw bytes out of the underlying <code>PyObject</code>. Fortunately <code>Foreign.Marshal.Alloc.alloca</code> comes to rescue and conveniently allocates addressable fields which I can then hand down to Python. Python puts the address and size of the underlying string buffer into these fields, which I can then read with <code>Foreign.Storable.peek</code> to copy the entire byte sequence into an independent <code>ByteString</code>:</p>
<div class="highlight"><pre>  <span class="n">fromPy</span> <span class="n">s</span> <span class="ow">=</span>
    <span class="n">alloca</span> <span class="o">$</span> <span class="nf">\</span><span class="n">s_buffer_ptr</span> <span class="ow">-&gt;</span>
    <span class="n">alloca</span> <span class="o">$</span> <span class="nf">\</span><span class="n">s_len_ptr</span> <span class="ow">-&gt;</span>
    <span class="n">withPyObject</span> <span class="n">s</span> <span class="o">$</span> <span class="nf">\</span><span class="n">raw</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
      <span class="n">result</span> <span class="ow">&lt;-</span> <span class="n">pyString_AsStringAndSize</span> <span class="n">raw</span> <span class="n">s_buffer_ptr</span> <span class="n">s_len_ptr</span>
      <span class="n">unless</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">throwCurrentPythonException</span>
      <span class="n">buffer</span> <span class="ow">&lt;-</span> <span class="n">peek</span> <span class="n">s_buffer_ptr</span>
      <span class="n">len</span> <span class="ow">&lt;-</span> <span class="n">peek</span> <span class="n">s_len_ptr</span>
      <span class="n">packCStringLen</span> <span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">fromIntegral</span> <span class="n">len</span><span class="p">)</span>
</pre></div>

<p>Converting from a <code>String</code> almost looks like converting from a <code>ByteString</code>, except that we need to encode the <code>String</code> to UTF-8 to pass it to <code>PyUnicode_FromStringAndSize</code>, which expects a UTF-8 encoded char array. Converting back is simple as well, because I can build upon the <code>ByteString</code> conversion from above. I just need to turn the Python unicode object into an encoded char array with <code>PyUnicode_AsUTF8String</code> which I can then convert to a <code>ByteString</code> and decode:</p>
<div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Object</span> <span class="kt">String</span> <span class="kr">where</span>
  <span class="n">toPy</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">useAsCStringLen</span> <span class="p">(</span><span class="kt">UTF8</span><span class="o">.</span><span class="n">fromString</span> <span class="n">s</span><span class="p">)</span> <span class="o">$</span> <span class="nf">\</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="ow">-&gt;</span>
    <span class="n">pyUnicode_FromStringAndSize</span> <span class="n">buffer</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="n">len</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">toPyObjectChecked</span>
  <span class="n">fromPy</span> <span class="n">o</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">withPyObject</span> <span class="n">o</span> <span class="n">pyUnicode_AsUTF8String</span> <span class="o">&gt;&gt;=</span> <span class="n">toPyObjectChecked</span>
    <span class="n">liftM</span> <span class="kt">UTF8</span><span class="o">.</span><span class="n">toString</span> <span class="p">(</span><span class="n">fromPy</span> <span class="n">s</span><span class="p">)</span>
</pre></div>

<h1 id="pygments-interface">Pygments interface</h1>
<p><a href="https://github.com/lunaryorn/blog/blob/36bef7de1a7914fa4bffdd28800dbd01f6ca719a/src/Text/Highlighting/Pygments.hs"><strong>Text.Highlighting.Pygments</strong></a> is the Pygments interface that builds upon this <a href="#convenient-haskell-api">Python API</a>.</p>
<p>I start with some type aliases for Pygments types. They don’t add additional type safety, because Python is dynamically typed anyway, but they make the type signatures a little nicer:</p>
<div class="highlight"><pre><span class="kr">type</span> <span class="kt">Lexer</span>     <span class="ow">=</span> <span class="kt">PyObject</span>
<span class="kr">type</span> <span class="kt">Formatter</span> <span class="ow">=</span> <span class="kt">PyObject</span>
</pre></div>

<p>Then I wrap the required functions from Pygments into convenient Haskell functions. <code>getLexerByName</code> gives me the Pygments Lexer for the name of a programming language:</p>
<div class="highlight"><pre><span class="nf">getLexerByName</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">Lexer</span>
<span class="nf">getLexerByName</span> <span class="n">name</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">initialize</span> <span class="kt">False</span>
  <span class="n">lexers</span> <span class="ow">&lt;-</span> <span class="n">importModule</span> <span class="s">&quot;pygments.lexers&quot;</span>
  <span class="n">get_lexer_by_name</span> <span class="ow">&lt;-</span> <span class="n">getAttr</span> <span class="n">lexers</span> <span class="s">&quot;get_lexer_by_name&quot;</span>
  <span class="n">pyName</span> <span class="ow">&lt;-</span> <span class="n">toPy</span> <span class="n">name</span>
  <span class="n">callObject</span> <span class="n">get_lexer_by_name</span> <span class="p">[</span><span class="n">pyName</span><span class="p">]</span> <span class="kt">[]</span>
</pre></div>

<p>The function</p>
<ol type="1">
<li>initializes the interpreter,</li>
<li>imports <code>pgyments.lexers</code>,</li>
<li>gets a reference to the underlying <code>get_lexer_by_name</code> function,</li>
<li>converts the given <code>language</code> to a Python object,</li>
<li>and ultimately calls <code>get_lexer_by_name</code> with the appropriate arguments.</li>
</ol>
<p>Note that this function is as safe as it can be when dealing with a dynamically typed language:</p>
<ul>
<li>It will never try to use invalid objects, because Python operations never fail silently. If any Python call fails, e.g. because Pygments is not installed, the Python interface throws a Haskell exception.</li>
<li>Even in case of an exception, the function does not leak memory. All references to Python objects are managed pointers which automatically free the underlying Python object when they go out of scope, whether by a normal return, or in case of an exception.</li>
</ul>
<p><code>highlight</code> highlights a given piece of code with a lexer and formatter:</p>
<div class="highlight"><pre><span class="nf">highlight</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Lexer</span> <span class="ow">-&gt;</span> <span class="kt">Formatter</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">String</span>
<span class="nf">highlight</span> <span class="n">code</span> <span class="n">lexer</span> <span class="n">formatter</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">initialize</span> <span class="kt">False</span>
  <span class="n">pygments</span> <span class="ow">&lt;-</span> <span class="n">importModule</span> <span class="s">&quot;pygments&quot;</span>
  <span class="n">py_highlight</span> <span class="ow">&lt;-</span> <span class="n">getAttr</span> <span class="n">pygments</span> <span class="s">&quot;highlight&quot;</span>
  <span class="n">codeObj</span> <span class="ow">&lt;-</span> <span class="n">toPy</span> <span class="n">code</span>
  <span class="n">callObject</span> <span class="n">py_highlight</span> <span class="p">[</span><span class="n">codeObj</span><span class="p">,</span> <span class="n">lexer</span><span class="p">,</span> <span class="n">formatter</span><span class="p">]</span> <span class="kt">[]</span> <span class="o">&gt;&gt;=</span> <span class="n">fromPy</span>
</pre></div>

<p>With these convenient wrappers I am now able to implement <code>toHtml</code>:</p>
<div class="highlight"><pre><span class="nf">toHtml</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">String</span>
<span class="nf">toHtml</span> <span class="n">code</span> <span class="n">language</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">formatters</span> <span class="ow">&lt;-</span> <span class="n">importModule</span> <span class="s">&quot;pygments.formatters&quot;</span>
  <span class="n">html_formatter</span> <span class="ow">&lt;-</span> <span class="n">getAttr</span> <span class="n">formatters</span> <span class="s">&quot;HtmlFormatter&quot;</span>
  <span class="n">cssclass_key</span> <span class="ow">&lt;-</span> <span class="n">toPy</span> <span class="s">&quot;cssclass&quot;</span>
  <span class="n">cssclass</span> <span class="ow">&lt;-</span> <span class="n">toPy</span> <span class="s">&quot;highlight&quot;</span>
  <span class="n">formatter</span> <span class="ow">&lt;-</span> <span class="n">callObject</span> <span class="n">html_formatter</span> <span class="kt">[]</span> <span class="p">[(</span><span class="n">cssclass_key</span><span class="p">,</span> <span class="n">cssclass</span><span class="p">)]</span>
  <span class="n">lexer</span> <span class="ow">&lt;-</span> <span class="n">getLexerByName</span> <span class="n">language</span>
  <span class="n">highlight</span> <span class="n">code</span> <span class="n">lexer</span> <span class="n">formatter</span>
</pre></div>

<p>This function first creates an instance of the <code>HtmlFormatter</code> class, by importing the <code>pygments.formatters</code> module, obtaining a reference to the class object, and calling the class object with some options to create a new instance.</p>
<p>Then it gets the lexer object, and passes these objects and the code to <code>highlight</code>. The result is a string containing HTML to highlight the given <code>code</code>.</p>
<h1 id="building">Building</h1>
<p>I use Cabal to build these modules. The corresponding <a href="https://github.com/lunaryorn/blog/blob/306c891845311a8a4e424cabfade4db07318c603/lunarsite.cabal">cabal file</a> is simple:</p>
<pre><code>executable lunarsite
  […]
  other-modules:       Foreign.Python
                       Foreign.Python.Native
                       Text.Highlighting.Pygments
                       Text.Highlighting.Pygments.Pandoc
  build-depends:       base &gt;=4.6 &amp;&amp; &lt;4.8,
                       bytestring &gt;=0.10 &amp;&amp; &lt; 0.11,
                       utf8-string &gt;=0.3 &amp;&amp; &lt;0.4,
                       pandoc-types &gt;=1.12 &amp;&amp; &lt;1.13,
                       pandoc &gt;=1.12 &amp;&amp; &lt;1.13
  build-tools:         hsc2hs

  if os(darwin)
     extra-libraries:   python2.7
     include-dirs:      /usr/include/python2.7
  else
     pkgconfig-depends: python ==2.7</code></pre>
<p>I enable <code>hsc2hs</code> in <code>build-tools</code> to compile <a href="#native-wrappers">Foreign.Python.Native</a>, and tell Cabal to link against Python 2.7.</p>
<p><code>pkg-config</code> is missing on OS X, but since the layout of the pre-installed system Python is fixed anyway, I just hard-code the library name and the include directory.</p>
<p>On other systems I just rely on Cabal’s built-in support for <code>pkg-config</code> to automatically determine the library name and the include directories for Python 2.7.</p>
<h1 id="lessons-learned">Lessons learned</h1>
<p>Calling Python from Haskell was much, much easier than I thought, thanks to Haskell’s good FFI, which takes over all marshaling of primitive types, and provides great utilities and helpers to marshal complex types.</p>
<p>It would even been even easier, however, if the C API of Python 2.7 was a little better, and had a little more consistent reference count semantics, and if Haskell supported varargs functions in its FFI.</p>
<p>While Python functions normally do not steal references and do not return borrowed references, there are some notable exceptions, which lead the entire attempt to provide a consistent API ad absurdum, since you still need to check any function carefully for how it handles the reference counts in its arguments and return values.</p>
<p>And since Haskell doesn’t support foreign varargs functions, I frequently had to manually assemble complex Python objects such as argument tuples using the lower-level API, instead of just calling <a href="https://docs.python.org/2/c-api/arg.html#Py_BuildValue"><code>Py_BuildValue</code></a> to build complex Python objects from C values directly.</p>
<p>Despite these minor nuisances working with Haskell’s FFI has been a really pleasant experience so far, and I’m truly surprised that a language which is generally renowned for its advancement of computer science also excels at the dirty low-level task of calling C libraries.</p>