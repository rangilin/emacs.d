<p>Ever wonder how Emacs *knows* that the point is next to a balanced expression like a bracket or a string? That <code>kill-sexp</code> or <code>up-list</code> knows how to kill the balanced expression at point or move up one level in a nested set of brackets, in just about any major mode out there?</p>
<p>At a higher level the mode author may choose to write his own parsing routines for handling balanced expressions in that particular mode; but unless your mode’s very special (LaTeX comes to mind) most choose to rely on Emacs’s own ability to parse certain recurring concepts that appear in most major modes — be it something as simple as <code>text-mode</code> or as complicated as a full-blown major mode. A few modes may augment this basic parser with additional functionality, but for a lot of languages (particularly C-like languages) — it’s more than enough.</p>
<p>The secret is <code>parse-partial-sexp</code> and <code>syntax-ppss</code>. The latter function is still an undocumented snippet in <code>syntax.el</code> and yet it’s a first-class citizen used in hundreds of places all over the Emacs elisp source code.</p>
<p>So what makes a barely-kept secret to mode writers such an interesting function? It possesses the unique ability to parse and understand common syntactic elements: comments; strings; and balanced expressions, like brackets. It uses Emacs’s syntax table, a giant key-value table used by modes and some commands to tell Emacs how it should treat alphabetical characters and special characters like <code>[</code> and <code>"</code>.</p>
<p>So the good news is all that information's already taken care of for you by the mode authors: all you have to do is think of instances where you may want to edit or move by syntax.</p>
<p>So let's say you want to switch the quote symbols in Python from single to double-quote or vice versa:</p>
<p></p><pre class="crayon-plain-tag">def foobar():
    s = 'Hello█ World'
    return s</pre><p></p>
<p>We want to run one command that turns <code>'Hello█ World'</code> into <code>"Hello█ World"</code> where █ is the point.</p>
<p>Because <code>syntax-ppss</code> understands the basics of our major mode's language syntax this is rather easy to do.</p>
<p>Let's write a function that determines if point is in a string or not (actually, such a function already exists in <code>thingatpt.el</code> called <code>in-string-p</code>):</p>
<p></p><pre class="crayon-plain-tag">(defun point-in-string-p (pt)
  "Returns t if PT is in a string"
  (eq 'string (syntax-ppss-context (syntax-ppss pt))))</pre><p></p>
<p>Here I'm using <code>syntax-ppss-context</code>, a helper function that can return three different states: <code>comment</code>, <code>string</code>, or <code>nil</code>.</p>
<p>If you eval <code>M-: (point-in-string-p (point))</code> you can test if the point in the active buffer is in a string or not.</p>
<p>Making a function that does the same for comments is trivial: replace <code>string</code> with <code>comment</code> and bob's your uncle.</p>
<p>The next piece of the puzzle is that we need to be able to move out of a string if we're in one or throw an error if we are not. We need to "move out" of it as we want to replace the quotes surrounding a string; the easiest way to do this reliably is to find the bounds of the string: the beginning and end.</p>
<p></p><pre class="crayon-plain-tag">(defun beginning-of-string ()
  "Moves to the beginning of a syntactic string"
  (interactive)
  (unless (point-in-string-p (point))
    (error "You must be in a string for this command to work"))
  (while (point-in-string-p (point))
    (forward-char -1))
  (point))</pre><p></p>
<p>This function is marked as interactive so it can be called through <code>M-x</code>, bound to a key, used in macros, and so forth. Then we test if we're not in a string: if we are not, we bail out with an error. You could remove that check and rely on the while loop failing the initial condition but then you wouldn't get an error message that would propagate.</p>
<p>The while loop itself is simple: as long as we're in a string go forward by negative one characters (that's the elisp convention for going backwards.) And finally we return the location of point.</p>
<p>The next step is to go to the end of the string. We can do that in two ways: extend <code>beginning-of-string</code> so it's generic and will take a direction: <code>-1</code> for backwards and <code>1</code> for forwards. The other is to use Emacs's own set of commands that work on s-expressions, like <code>forward-sexp</code> (<code>C-M-f</code>.)</p>
<p>The latter is easier (and the former left as an exercise to the reader.) What we need now are the points immediately before and after each quote symbol before we start changing things.</p>
<p>If we change the first quote symbol at the beginning of the string then we are left with invalid syntax and Emacs's <code>parse-partial-sexp</code> cannot reconcile the two mismatched quotes when we call <code>forward-sexp</code>. So we have to store the positions first, and <em>then</em> change the quotes.</p>
<p>The other thing we have to remember is to move the point back to the original position where the user called the command; not doing so is considered bad form in elisp land: you should not move the point unless the point (ha) of the command is to move around the buffer.</p>
<p></p><pre class="crayon-plain-tag">(defun swap-quotes ()
  "Swaps the quote symbols in a \\[python-mode] string"
  (interactive)
  (save-excursion
    (let ((bos (save-excursion
                 (beginning-of-string)))
          (eos (save-excursion
                 (beginning-of-string)
                 (forward-sexp)
                 (point)))
          (replacement-char ?\'))
      (goto-char bos)
      ;; if the following character is a single quote then the
      ;; `replacement-char' should be a double quote.
      (when (eq (following-char) ?\')
          (setq replacement-char ?\"))
      (delete-char 1)
      (insert replacement-char)
      (goto-char eos)
      (delete-char -1)
      (insert replacement-char))))</pre><p></p>
<p>This interactive command will swap the quotes of the string point is in. It starts out by recording the position of the beginning and end of the string. If we're not in a string, the command will exit with the error propagated from the <code>beginning-of-string</code> command above.</p>
<p>Next we go to the beginning of the string and we check what the replacement character should be and delete the next character and insert our replacement character. The same is repeated for the end of the string. And finally because we <code>save-excursion</code> at the beginning of the command the point is placed back at its original position.</p>
<p>There are a few obvious improvements: the delete/insertion code could be abstracted into a <code>letf</code>-bound function - but that seems like overkill. Another optimization is supporting triple quotes by using the <code>looking-at</code> function and passing it a regular expression that matches single or double quotes, in singles or triples, and replacing the match with the replacement character.</p>
<p>But the function works. And it could easily work for other modes with interchangeable quotes -- or even other paired expressions, like brackets. In fact, making it work with brackets is easier as the built-in command <code>up-list</code> (<code>C-M-u</code>) will go to the beginning of a balanced pair and <code>forward-sexp</code> will go to the end of the balanced pair at point.</p>
<p>Thanks to a little-known feature of Emacs's syntax parser you can make some simple assumptions about the text in a buffer and act on it in a structured manner.</p>
<p><a class="a2a_button_google_plusone addtoany_special_service"></a><a class="a2a_button_twitter_tweet addtoany_special_service"></a><a class="a2a_dd a2a_target addtoany_share_save" href="http://www.addtoany.com/share_save#url=http%3A%2F%2Fwww.masteringemacs.org%2Farticles%2F2014%2F08%2F26%2Fswapping-quote-symbols-emacs-parsepartialsexp%2F&amp;title=Swapping%20quote%20symbols%20in%20Emacs%20with%20parse-partial-sexp" id="wpa2a_8">Share</a></p>