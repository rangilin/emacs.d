<div class="alert alert-warning">
<p><strong>Warning!</strong></p>
<p>If you use a recent build of Emacs trunk, be sure to read the <a href="/2013/06/25/introducing-with-eval-after-load.html">follow up</a> on the new Emacs macro <code>with-eval-after-load</code>.</p>
</div>
<p>In this post we will explore <code>eval-after-load</code> and its relation to byte compilation. We introduce <code>eval-after-load</code>, and point out the lack of byte compilation as serious drawback. Eventually we will present a macro around <code>eval-after-load</code> which compiles <code>eval-after-load</code> forms, and explain its advantages and disadvantages.</p>
<h1 id="introducing-eval-after-load">Introducing eval-after-load</h1>
<p>The GNU Emacs function <code>eval-after-load</code> schedules a form for evaluation after a named feature or a file:</p>
<div class="highlight"><pre><span class="p">(</span><span class="nv">eval-after-load</span> <span class="ss">&#39;ido</span>
  <span class="o">&#39;</span><span class="p">(</span><span class="k">setq</span> <span class="nv">ido-enable-flex-matching</span> <span class="no">t</span>      <span class="c1">; Match characters if string doesn&#39;t</span>
                                         <span class="c1">; match</span>
         <span class="nv">ido-create-new-buffer</span> <span class="ss">&#39;always</span>   <span class="c1">; Create a new buffer if nothing</span>
                                         <span class="c1">; matches</span>
         <span class="nv">ido-use-filename-at-point</span> <span class="ss">&#39;guess</span>
         <span class="nv">ido-default-file-method</span> <span class="ss">&#39;selected-window</span><span class="p">))</span>
</pre></div>

<p>In this example, the <code>setq</code> form is scheduled for evaluation after the feature <code>ido</code> is loaded.</p>
<p>If you use <code>eval-after-load</code> in your <code>init.el</code>, Emacs will start faster, because configuration and customization code is delayed until after the corresponding packages are actually loaded. Moreover, the byte compiler will not emit bogus warnings about assignment to free variables for your <code>setq</code> forms.</p>
<p>Many users do not use <code>eval-after-load</code> directly, but write a helper macro instead to allow for multiple body forms and get rid of the quoting:</p>
<div class="highlight"><pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">stante-after</span> <span class="p">(</span><span class="nv">feature</span> <span class="k">&amp;rest</span> <span class="nv">forms</span><span class="p">)</span>
  <span class="s">&quot;After FEATURE is loaded, evaluate FORMS.</span>

<span class="s">FEATURE may be an unquoted feature symbol or a file name, see</span>
<span class="s">`eval-after-load&#39;.&quot;</span>
  <span class="p">(</span><span class="k">declare</span> <span class="p">(</span><span class="nv">indent</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nv">debug</span> <span class="no">t</span><span class="p">))</span>
  <span class="o">`</span><span class="p">(</span><span class="nv">eval-after-load</span> <span class="ss">&#39;,feature</span>
     <span class="o">&#39;</span><span class="p">(</span><span class="k">progn</span> <span class="o">,@</span><span class="nv">forms</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">stante-after</span> <span class="nv">python</span>
  <span class="p">(</span><span class="nv">add-hook</span> <span class="ss">&#39;python-mode-hook</span> <span class="nf">#&#39;</span><span class="nv">subword-mode</span><span class="p">)</span>
  <span class="p">(</span><span class="k">setq</span> <span class="nv">python-check-command</span> <span class="s">&quot;flake8&quot;</span><span class="p">))</span>
</pre></div>

<p>With this macro, we do not need to quote the feature name or the form. Moreover we can use multiple forms at once.</p>
<h1 id="lacking-byte-compilation-in-eval-after-load">Lacking byte-compilation in eval-after-load</h1>
<p>There is a serious drawback in using <code>eval-after-load</code>: The function does <strong>not</strong> compile its body. If you are heavily using <code>eval-after-load</code> in your <code>init.el</code>, like I do, most of it will not be compiled actually!</p>
<p>Thus initialization will be somewhat slower, and even worse, you will <strong>not</strong> be warned by the compiler, if you assign to free variables or call undefined functions, which often indicates mistakes like typos in variable names.</p>
<h1 id="implementing-byte-compilation">Implementing byte compilation</h1>
<p>This issue is reported as <a href="http://debbugs.gnu.org/cgi/bugreport.cgi?bug=13021">bug #13021</a>. While the actual discussion of this feature has apparently dropped off, the bug report includes an implementation of a byte-compiling <code>eval-after-load</code>:</p>
<div class="highlight"><pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">stante-after</span> <span class="p">(</span><span class="nv">feature</span> <span class="k">&amp;rest</span> <span class="nv">forms</span><span class="p">)</span>
  <span class="s">&quot;After FEATURE is loaded, evaluate FORMS.</span>

<span class="s">FORMS is byte compiled.</span>

<span class="s">FEATURE may be a named feature or a file name, see</span>
<span class="s">`eval-after-load&#39; for details.&quot;</span>
  <span class="p">(</span><span class="k">declare</span> <span class="p">(</span><span class="nv">indent</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nv">debug</span> <span class="no">t</span><span class="p">))</span>
  <span class="c1">;; Byte compile the body.  If the feature is not available, ignore warnings.</span>
  <span class="c1">;; Taken from</span>
  <span class="c1">;; http://lists.gnu.org/archive/html/bug-gnu-emacs/2012-11/msg01262.html</span>
  <span class="o">`</span><span class="p">(</span><span class="o">,</span><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nb">not</span> <span class="nv">byte-compile-current-file</span><span class="p">)</span>
             <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">symbolp</span> <span class="nv">feature</span><span class="p">)</span>
                 <span class="p">(</span><span class="nb">require</span> <span class="nv">feature</span> <span class="no">nil</span> <span class="ss">:no-error</span><span class="p">)</span>
               <span class="p">(</span><span class="nb">load</span> <span class="nv">feature</span> <span class="ss">:no-message</span> <span class="ss">:no-error</span><span class="p">)))</span>
         <span class="ss">&#39;progn</span>
       <span class="p">(</span><span class="nv">message</span> <span class="s">&quot;stante-after: cannot find %s&quot;</span> <span class="nv">feature</span><span class="p">)</span>
       <span class="ss">&#39;with-no-warnings</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">eval-after-load</span> <span class="ss">&#39;,feature</span>
      <span class="o">`</span><span class="p">(</span><span class="nb">funcall</span> <span class="p">(</span><span class="k">function</span> <span class="o">,</span><span class="p">(</span><span class="k">lambda</span> <span class="p">()</span> <span class="o">,@</span><span class="nv">forms</span><span class="p">))))))</span>
</pre></div>

<p>Because this implementation is rather convoluted, we will reproduce it step by step in the following. pFor the sake of brevity, we will omit the docstring and the <code>declare</code> form in subsequent definitions of the macro. If you want to copy this macro to your own <code>init.el</code>, be sure to use the definition above, not any of those below!</p>
<h1 id="unveiling-the-implementation">Unveiling the implementation</h1>
<p>In our simple definition of <code>stante-after</code> above we used a standard quoted form. The byte compiler cannot compile such forms, because they can contain arbitrary data (i.e. quoted lists), and not just executable code.</p>
<h2 id="the-basic-idea">The basic idea</h2>
<p>We need to tell the byte compiler explicitly, that the <code>eval-after-load</code> form is executable code, by quoting the forms with a <a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Anonymous-Functions.html#index-function-753">“function” quote</a>:</p>
<blockquote>
<p>This special form returns FUNCTION-OBJECT without evaluating it. In this, it is similar to <code>quote</code> […]. But unlike <code>quote</code>, it also serves as a note to the Emacs evaluator and byte-compiler that FUNCTION-OBJECT is intended to be used as a function. Assuming FUNCTION-OBJECT is a valid lambda expression, this has two effects:</p>
<ul>
<li>When the code is byte-compiled, FUNCTION-OBJECT is compiled into a byte-code function object […].</li>
</ul>
<p>[…]</p>
</blockquote>
<p>As <code>function</code> wants a function object, we wrap our forms into a <code>lambda</code> instead of a <code>progn</code>:</p>
<div class="highlight"><pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">stante-after</span> <span class="p">(</span><span class="nv">feature</span> <span class="k">&amp;rest</span> <span class="nv">forms</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="nv">eval-after-load</span> <span class="ss">&#39;,feature</span>
     <span class="o">`</span><span class="p">(</span><span class="nb">funcall</span> <span class="p">(</span><span class="k">function</span> <span class="o">,</span><span class="p">(</span><span class="k">lambda</span> <span class="p">()</span> <span class="o">,@</span><span class="nv">forms</span><span class="p">)))))</span>

<span class="p">(</span><span class="nv">stante-after</span> <span class="nv">python</span>
  <span class="p">(</span><span class="nv">add-hook</span> <span class="ss">&#39;python-mode-hook</span> <span class="nf">#&#39;</span><span class="nv">subword-mode</span><span class="p">)</span>
  <span class="p">(</span><span class="k">setq</span> <span class="nv">python-check-command</span> <span class="s">&quot;flake8&quot;</span><span class="p">))</span>
</pre></div>

<p>Now the <code>forms</code> are compiled with the surrounding code.</p>
<h2 id="avoiding-bogus-warnings">Avoiding bogus warnings</h2>
<p>If you try this macro, you will see a lot of bogus warnings about undefined functions or free variables during byte compilation, even though the functions and warnings are defined in the corresponding <code>feature</code>:</p>
<pre><code>init.el:1112:9:Warning: assignment to free variable `python-check-command&#39;</code></pre>
<p>The byte compiler does simply not know about these functions and variables, because the <code>feature</code> is never actually loaded during byte compilation. To avoid these warnings, we consequently need to load the feature during byte compilation:</p>
<div class="highlight"><pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">stante-after</span> <span class="p">(</span><span class="nv">feature</span> <span class="k">&amp;rest</span> <span class="nv">forms</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">boundp</span> <span class="ss">&#39;byte-compile-current-file</span><span class="p">)</span> <span class="nv">byte-compile-current-file</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">symbolp</span> <span class="nv">feature</span><span class="p">)</span> <span class="p">(</span><span class="nb">require</span> <span class="nv">feature</span><span class="p">)</span> <span class="p">(</span><span class="nb">load</span> <span class="nv">feature</span><span class="p">)))</span>
  <span class="o">`</span><span class="p">(</span><span class="nv">eval-after-load</span> <span class="ss">&#39;,feature</span>
     <span class="o">`</span><span class="p">(</span><span class="nb">funcall</span> <span class="p">(</span><span class="k">function</span> <span class="o">,</span><span class="p">(</span><span class="k">lambda</span> <span class="p">()</span> <span class="o">,@</span><span class="nv">forms</span><span class="p">)))))</span>
</pre></div>

<p>The <code>if</code> form loads the feature or file with <code>require</code> and <code>load</code> respectively, depending on the type of the <code>feature</code> argument. Note that the <code>if</code> form is <strong>not</strong> part of the macro expansion. Thus it is <strong>executed</strong> during macro expansion, instead of appearing in the expanded body.</p>
<p>Since macros are expanded during byte compilation, the <code>feature</code> is now loaded during byte compilation. The compiled code only contains the macro expansion, so the feature is not loaded during evaluation.</p>
<p>We wrap the <code>if</code> form into a <code>when</code> conditional which is only entered if <code>byte-compile-current-file</code> is non-nil, to avoid that features and libraries are loaded if the macro is expanded at runtime, which happens if you didn’t byte-compile your init file.</p>
<h2 id="handling-missing-features-gracefully">Handling missing features gracefully</h2>
<p>If all features are available during byte compilation, we are done now. However, if some of the features in your <code>init.el</code> are not available during compilation, it got much worse now:</p>
<div class="highlight"><pre><span class="p">(</span><span class="nv">stante-after</span> <span class="nv">tex</span>
  <span class="p">(</span><span class="k">setq</span> <span class="nv">TeX-parse-self</span> <span class="no">t</span>                <span class="c1">; Parse documents to provide completion</span>
                                        <span class="c1">; for packages, etc.</span>
        <span class="nv">TeX-auto-save</span> <span class="no">t</span>                 <span class="c1">; Automatically save</span>
        <span class="nv">TeX-clean-confirm</span> <span class="no">nil</span><span class="p">))</span>         <span class="c1">; Do not ask for confirmation when</span>
                                        <span class="c1">; cleaning</span>
</pre></div>

<p>The <code>tex</code> feature comes from <a href="http://www.gnu.org/software/auctex/">AUCTeX</a>. If this library is not installed, byte compilation brutally fails now:</p>
<pre><code>init.el:830:1:Error: Cannot open load file: tex</code></pre>
<p>We obviously need to handle the missing features more gracefully:</p>
<div class="highlight"><pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">stante-after</span> <span class="p">(</span><span class="nv">feature</span> <span class="k">&amp;rest</span> <span class="nv">forms</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">boundp</span> <span class="ss">&#39;byte-compile-current-file</span><span class="p">)</span> <span class="nv">byte-compile-current-file</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">symbolp</span> <span class="nv">feature</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">require</span> <span class="nv">feature</span> <span class="no">nil</span> <span class="ss">:no-error</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">load</span> <span class="nv">feature</span> <span class="ss">:no-message</span> <span class="ss">:no-error</span><span class="p">)))</span>
  <span class="o">`</span><span class="p">(</span><span class="nv">eval-after-load</span> <span class="ss">&#39;,feature</span>
     <span class="o">`</span><span class="p">(</span><span class="nb">funcall</span> <span class="p">(</span><span class="k">function</span> <span class="o">,</span><span class="p">(</span><span class="k">lambda</span> <span class="p">()</span> <span class="o">,@</span><span class="nv">forms</span><span class="p">)))))</span>
</pre></div>

<p>The <code>:no-error</code> argument to <code>load</code> and <code>require</code> respectively suppresses errors if the given file or feature could not be loaded. Actually any non-nil argument will do, but I prefer verbose symbols for the sake of clarity.</p>
<h2 id="avoiding-warnings-from-missing-features">Avoiding warnings from missing features</h2>
<p>We are almost there now. There is just a little nuisance left: If the feature is not available, the byte compiler will again emit bogus warnings:</p>
<pre><code>init.el:821:9:Warning: assignment to free variable `TeX-parse-self&#39;
init.el:823:9:Warning: assignment to free variable `TeX-auto-save&#39;
init.el:824:9:Warning: assignment to free variable `TeX-clean-confirm&#39;</code></pre>
<p>We can fix this problem by wrapping the <code>eval-after-load</code> form with <code>with-no-warnings</code>, if the feature is not available. <code>with-no-warnings</code> suppresses all byte compiler warnings in the contained block. Both <code>load</code> and <code>require</code> will return <code>nil</code> if the feature or file is not available:</p>
<div class="highlight"><pre><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">stante-after</span> <span class="p">(</span><span class="nv">feature</span> <span class="k">&amp;rest</span> <span class="nv">forms</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="o">,</span><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">boundp</span> <span class="ss">&#39;byte-compile-current-file</span><span class="p">))</span>
             <span class="p">(</span><span class="nb">not</span> <span class="nv">byte-compile-current-file</span><span class="p">)</span>
             <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">symbolp</span> <span class="nv">feature</span><span class="p">)</span>
                 <span class="p">(</span><span class="nb">require</span> <span class="nv">feature</span> <span class="no">nil</span> <span class="ss">:no-error</span><span class="p">)</span>
               <span class="p">(</span><span class="nb">load</span> <span class="nv">feature</span> <span class="ss">:no-message</span> <span class="ss">:no-error</span><span class="p">)))</span>
         <span class="ss">&#39;progn</span>
       <span class="p">(</span><span class="nv">message</span> <span class="s">&quot;stante-after: cannot find %s&quot;</span> <span class="nv">feature</span><span class="p">)</span>
       <span class="ss">&#39;with-no-warnings</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">eval-after-load</span> <span class="ss">&#39;,feature</span>
      <span class="o">`</span><span class="p">(</span><span class="nb">funcall</span> <span class="p">(</span><span class="k">function</span> <span class="o">,</span><span class="p">(</span><span class="k">lambda</span> <span class="p">()</span> <span class="o">,@</span><span class="nv">forms</span><span class="p">))))))</span>
</pre></div>

<p>We introduce another <code>if</code> that wraps around the <code>eval-after-load</code> during expansion, and turn our previous <code>when</code> into a <code>or</code>. If the feature is not available during byte compilation, that is, if the <code>or</code> returns <code>nil</code>, we print a single warning, and wrap the <code>eval-after-load</code> with <code>with-not-warnings</code>. Otherwise we just wrap it into a <code>progn</code> to preserve the warnings.</p>
<p>Now we are done. With this macro, <code>eval-after-load</code> forms are compiled to byte code, giving you both the speedup of byte code, and the helpful warnings and hints of the byte compiler.</p>